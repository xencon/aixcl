#!/usr/bin/env bash

set -e  # Exit on error
set -u  # Treat unset variables as an error
set -o pipefail  # Catch errors in pipelines

# Get script directory early (needed for compose file paths)
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Safe function to load environment variables from .env file
load_env_file() {
    local env_file="$1"
    if [ -f "$env_file" ]; then
        # Use a safer method to parse .env files
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and comments
            [ -z "$line" ] && continue
            [ "${line#\#}" != "$line" ] && continue
            
            # Extract key and value, handling quoted values
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                
                # Remove leading/trailing whitespace from key
                key="${key%"${key##*[![:space:]]}"}"
                key="${key#"${key%%[![:space:]]*}"}"
                
                # Remove leading/trailing whitespace from value
                value="${value%"${value##*[![:space:]]}"}"
                value="${value#"${value%%[![:space:]]*}"}"
                
                # Remove surrounding quotes if present
                if [[ "$value" =~ ^\".*\"$ ]]; then
                    value="${value#\"}"
                    value="${value%\"}"
                elif [[ "$value" =~ ^\'.*\'$ ]]; then
                    value="${value#\'}"
                    value="${value%\'}"
                fi
                
                # Only export if key is not empty and contains valid characters
                if [ -n "$key" ] && [[ "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                    export "$key"="$value"
                else
                    echo "‚ö†Ô∏è Skipping invalid environment variable key: '$key'"
                fi
            fi
        done < "$env_file"
    fi
}

# Load environment variables from .env file
load_env_file ".env"

# Allow custom Docker Compose file via environment variable
COMPOSE_FILE=${COMPOSE_FILE:-docker-compose.yml}

# Sanitize COMPOSE_FILE
# Reject any value containing non-alphanumeric, dash, underscore, dot or slash
# Updated regex to properly handle file paths and prevent directory traversal
if [[ ! "$COMPOSE_FILE" =~ ^[A-Za-z0-9._/-]+$ ]] || [[ "$COMPOSE_FILE" =~ \.\. ]] || [[ "$COMPOSE_FILE" =~ ^/ ]]; then
    echo "‚ùå Invalid COMPOSE_FILE value: $COMPOSE_FILE"
    echo "   Allowed characters: A-Z, a-z, 0-9, ., _, -, /"
    echo "   Cannot start with / or contain .."
    exit 1
fi

# Use array for safer command construction
COMPOSE_CMD=(docker-compose -f "${COMPOSE_FILE}")
COMPOSE_WORKDIR="${SCRIPT_DIR}/services"
CONTAINER_NAME="open-webui"

# Define all services from docker-compose.yml
# This list should match the services defined in docker-compose.yml
ALL_SERVICES=(
    "ollama"
    "open-webui"
    "llm-council"
    "postgres"
    "pgadmin"
    "watchtower"
    "prometheus"
    "grafana"
    "cadvisor"
    "node-exporter"
    "postgres-exporter"
    "nvidia-gpu-exporter"
    "loki"
    "promtail"
)

# Function to validate service name
function is_valid_service() {
    local service="$1"
    for valid_service in "${ALL_SERVICES[@]}"; do
        if [ "$service" = "$valid_service" ]; then
            return 0
        fi
    done
    return 1
}

# Get the actual Ollama container name (handles hash-prefixed containers)
function get_ollama_container() {
    docker ps --format "{{.Names}}" 2>/dev/null | grep -E "^ollama$|_[0-9a-f]+_ollama$|^[0-9a-f]+_ollama$" | head -1
}

# Function to get container name from service name
function get_container_name() {
    local service="$1"
    case "$service" in
        "open-webui")
            echo "open-webui"
            ;;
        "node-exporter")
            echo "node-exporter"
            ;;
        "postgres-exporter")
            echo "postgres-exporter"
            ;;
        "nvidia-gpu-exporter")
            echo "nvidia-gpu-exporter"
            ;;
        *)
            echo "$service"
            ;;
    esac
}

# Detect if NVIDIA GPU is available
function has_nvidia() {
    if command -v nvidia-smi >/dev/null 2>&1; then
        nvidia-smi >/dev/null 2>&1 && return 0 || return 1
    fi
    if docker info 2>/dev/null | grep -qi "nvidia"; then
        return 0
    fi
    return 1
}

# Detect if running on ARM64 architecture
function is_arm64() {
    local arch=$(uname -m)
    case "$arch" in
        arm64|aarch64)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Build docker-compose command with optional GPU and ARM overrides if present
function set_compose_cmd() {
    local services_dir="${SCRIPT_DIR}/services"
    local files=( -f "${COMPOSE_FILE}" )
    
    # Check for ARM64 architecture
    if is_arm64 && [ -f "${services_dir}/docker-compose.arm.yml" ]; then
        echo "Detected ARM64 architecture. Enabling ARM platform overrides."
        files+=( -f docker-compose.arm.yml )
    fi
    
    # Check for NVIDIA GPU
    if has_nvidia && [ -f "${services_dir}/docker-compose.gpu.yml" ]; then
        echo "Detected NVIDIA GPU. Enabling GPU overrides."
        files+=( -f docker-compose.gpu.yml )
    else
        echo "No NVIDIA GPU detected. Running without GPU overrides."
    fi
    
    COMPOSE_CMD=(docker-compose "${files[@]}")
    COMPOSE_WORKDIR="${services_dir}"
}

# Helper function to run docker-compose commands from the services directory
function run_compose() {
    if [ -z "${COMPOSE_WORKDIR}" ]; then
        echo "‚ùå Error: COMPOSE_WORKDIR is not set. Please call set_compose_cmd() first."
        return 1
    fi
    if [ ! -d "${COMPOSE_WORKDIR}" ]; then
        echo "‚ùå Error: Services directory does not exist: ${COMPOSE_WORKDIR}"
        return 1
    fi
    (cd "${COMPOSE_WORKDIR}" && "${COMPOSE_CMD[@]}" "$@")
}

# Source the autocomplete script if it exists (with security validation)
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
COMPLETION_SCRIPT="${SCRIPT_DIR}/completion/aixcl.bash"
if [ -f "$COMPLETION_SCRIPT" ] && [[ "$COMPLETION_SCRIPT" =~ ^/ ]] && [ -r "$COMPLETION_SCRIPT" ]; then
    source "$COMPLETION_SCRIPT"
fi

function check_env() {
    echo "Checking environment dependencies..."
    local missing_deps=0

    local is_wsl=0
    if grep -qi "microsoft" /proc/sys/kernel/osrelease 2>/dev/null || \
       grep -qi "microsoft" /proc/version 2>/dev/null; then
        is_wsl=1
        echo "‚ÑπÔ∏è  Windows Subsystem for Linux detected. GPU checks rely on nvidia-smi/docker instead of lspci."
    fi

    # Check Docker
    if ! command -v docker &> /dev/null; then
        echo "‚ùå Docker is not installed"
        echo "   Install from: https://docs.docker.com/get-docker/"
        missing_deps=1
    else
        echo "‚úÖ Docker is installed"
        # Check if Docker daemon is running
        if ! docker info &> /dev/null; then
            echo "‚ùå Docker daemon is not running"
            echo "   Start with: sudo systemctl start docker"
            missing_deps=1
        else
            echo "‚úÖ Docker daemon is running"
        fi
    fi

    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        echo "‚ùå Docker Compose is not installed"
        echo "   Install from: https://docs.docker.com/compose/install/"
        missing_deps=1
    else
        echo "‚úÖ Docker Compose is installed"
    fi

    # Check Bash shell
    echo -e "\nChecking shell environment..."
    if ! command -v bash &> /dev/null; then
        echo "‚ùå Bash shell is not installed"
        echo "   Install bash to continue: https://www.gnu.org/software/bash/"
        missing_deps=1
    else
        echo "‚úÖ Bash shell is available"
    fi

    # Check NVIDIA drivers and toolkit (optional)
    echo -e "\nChecking NVIDIA support..."
    local os_id=""
    local os_pretty=""
    if [ -f /etc/os-release ]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        os_id="${ID:-}"
        os_pretty="${PRETTY_NAME:-$os_id}"
    fi

    if [ -n "$os_pretty" ]; then
        echo "Detected operating system: $os_pretty"
    else
        echo "‚ö†Ô∏è Could not determine operating system (using generic GPU checks)"
    fi

    local has_gpu_hardware=0
    if command -v lspci &> /dev/null; then
        if lspci | grep -qi "nvidia"; then
            echo "‚úÖ NVIDIA GPU hardware detected"
            has_gpu_hardware=1
        else
            echo "‚ö†Ô∏è NVIDIA GPU hardware not detected"
        fi
    else
        if [ "$is_wsl" -eq 1 ]; then
            echo "‚ö†Ô∏è lspci is unavailable in WSL; falling back to runtime detection."
            if command -v nvidia-smi &> /dev/null && nvidia-smi &> /dev/null; then
                echo "‚úÖ NVIDIA GPU support detected via nvidia-smi"
                has_gpu_hardware=1
            elif [ -e /dev/dxg ]; then
                echo "‚úÖ NVIDIA GPU hardware exposed via /dev/dxg"
                has_gpu_hardware=1
            elif has_nvidia; then
                echo "‚úÖ NVIDIA GPU support detected via Docker runtime checks"
                has_gpu_hardware=1
            else
                echo "‚ÑπÔ∏è  Unable to confirm NVIDIA GPU support in WSL."
                echo "   If you expect GPU access, ensure you've installed the Windows CUDA drivers"
                echo "   and enabled GPU sharing in WSL: https://learn.microsoft.com/windows/wsl/tutorials/gpu-compute"
            fi
        else
            echo "‚ö†Ô∏è Unable to detect GPU hardware (missing lspci command)"
            echo "   Install pciutils to enable hardware detection (e.g., sudo apt install pciutils)"
        fi
    fi

    if command -v nvidia-smi &> /dev/null; then
        echo "‚úÖ NVIDIA drivers installed"
    elif [ "$has_gpu_hardware" -eq 1 ]; then
        echo "‚ùå NVIDIA drivers not found"
        case "$os_id" in
            ubuntu|debian)
                echo "   Install drivers with: sudo ubuntu-drivers autoinstall"
                ;;
            fedora)
                echo "   Install drivers with RPM Fusion: sudo dnf install akmod-nvidia xorg-x11-drv-nvidia-cuda"
                ;;
            *)
                echo "   Refer to NVIDIA docs for driver installation: https://www.nvidia.com/Download/index.aspx"
                ;;
        esac
    else
        echo "‚ö†Ô∏è NVIDIA drivers not found (no GPU detected)"
    fi

    # Check NVIDIA Container Toolkit
    if command -v nvidia-container-cli &> /dev/null; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    elif command -v dpkg &> /dev/null && dpkg -l | grep -q nvidia-container-toolkit; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    elif command -v rpm &> /dev/null && rpm -qa | grep -q nvidia-container-toolkit; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    else
        echo "‚ö†Ô∏è NVIDIA Container Toolkit not found (optional)"
        case "$os_id" in
            ubuntu|debian)
                echo "   Install toolkit with:"
                echo "   sudo apt update && sudo apt install -y nvidia-container-toolkit"
                ;;
            fedora)
                echo "   Install toolkit with:"
                echo "   sudo dnf config-manager --add-repo https://nvidia.github.io/libnvidia-container/stable/fedora/libnvidia-container.repo"
                echo "   sudo dnf install -y nvidia-container-toolkit"
                ;;
            *)
                echo "   Install instructions: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html"
                ;;
        esac
    fi

    # Check available disk space
    echo -e "\nChecking system resources..."
    local required_space=10 # GB
    local available_space=$(df -BG "$(pwd)" | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [ "$available_space" -lt "$required_space" ]; then
        echo "‚ùå Insufficient disk space. Required: ${required_space}GB, Available: ${available_space}GB"
        missing_deps=1
    else
        echo "‚úÖ Sufficient disk space available"
    fi

    # Check memory
    local total_mem=$(free -g | awk '/^Mem:/{print $2}')
    if [ "$total_mem" -lt 8 ]; then
        echo "‚ö†Ô∏è Low memory detected (${total_mem}GB). Recommended: 8GB+"
    else
        echo "‚úÖ Sufficient memory available"
    fi

    if [ $missing_deps -eq 1 ]; then
        echo -e "\n‚ùå Environment check failed. Please address the issues above."
        return 1
    else
        echo -e "\n‚úÖ Environment check passed! You're ready to run AIXCL."
        return 0
    fi
}

function generate_pgadmin_config() {
    echo "Generating pgAdmin server configuration..."
    
    # Validate required environment variables
    if [ -z "${POSTGRES_USER}" ] || [ -z "${POSTGRES_PASSWORD}" ]; then
        echo "‚ùå Error: POSTGRES_USER and POSTGRES_PASSWORD must be set in .env file"
        echo "   Please check your .env file and ensure these variables are configured"
        return 1
    fi
    
    # Create pgadmin-servers.json with populated environment values
    cat > pgadmin-servers.json << EOF
{
  "Servers": {
    "1": {
      "Group": "Servers",
      "Name": "AIXCL",
      "Host": "localhost",
      "Port": 5432,
      "MaintenanceDB": "postgres",
      "Username": "${POSTGRES_USER}",
      "Password": "${POSTGRES_PASSWORD}",
      "SSLMode": "prefer",
      "Favorite": true
    }
  }
}
EOF
    
    # Set restrictive file permissions (read/write for owner only)
    chmod 600 pgadmin-servers.json
    
    echo "‚úÖ Generated pgadmin-servers.json with populated values and secure permissions"
}

function start() {
    echo "Starting Docker Compose deployment..."
    
    # Check for .env file and create from .env.example if missing
    if [ ! -f .env ]; then
        if [ -f .env.example ]; then
            echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
            cp .env.example .env
            echo "‚úÖ Created .env file from .env.example"
            # Reload environment variables after creating .env file
            load_env_file ".env"
        else
            echo "‚ùå Error: Neither .env nor .env.example file found"
            echo "   Please create a .env file with the required configuration"
            exit 1
        fi
    fi
    
    # Generate pgAdmin configuration with populated values
    generate_pgadmin_config
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "Services are already running. Use 'stop' first if you want to restart."
        exit 1
    fi
    
    echo "Pulling latest images..."
    run_compose pull
    
    echo "Starting services..."
    run_compose up -d
    
    echo "Waiting for services to be ready..."
    for i in {1..30}; do
        if            curl -s -o /dev/null -w "%{http_code}" http://localhost:11434/api/version 2>/dev/null | grep -q "200" && \
           curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null | grep -q "200" && \
           curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null | grep -q "200" && \
           docker exec postgres pg_isready -U webui >/dev/null 2>&1; then
            echo "All services are up and running!"
            status
            return 0
        fi
        echo "Waiting for services to become available... ($i/30)"
        sleep 2
    done
    
    echo "Error: Services did not start properly within timeout period"
    status
    exit 1
}

function stop() {
    echo "Stopping Docker Compose deployment..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
        echo "Services are not running."
        return 0
    fi
    
    echo "Stopping services gracefully..."
    run_compose down --remove-orphans
    
    echo "Waiting for containers to stop..."
    for i in {1..15}; do
        if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
            echo "All services stopped successfully."
            return 0
        fi
        echo "Waiting for services to stop... ($i/15)"
        sleep 2
    done
    
    echo "Warning: Services did not stop gracefully. Forcing shutdown..."
    run_compose down --remove-orphans -v
    docker ps -q | xargs -r docker stop
    
    echo "All services have been stopped."
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
}

function restart() {
    echo "Restarting services..."
    stop
    sleep 5
    start
}

function start_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service start <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local service="$1"
    local force_recreate="${2:-false}"  # Optional second parameter to force recreate
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    # Check if service is already running (handle both exact name and hash-prefixed names)
    if docker ps --format "{{.Names}}" | grep -qE "^${container_name}$|_[0-9a-f]+_${container_name}$|^[0-9a-f]+_${container_name}$"; then
        echo "Service '$service' is already running."
        return 0
    fi
    
    # Remove any existing containers (running or stopped) to avoid ContainerConfig errors
    # This is especially important after rebuilds when docker-compose tries to recreate containers
    echo "Cleaning up any existing containers for $service..."
    run_compose rm -f "$service" 2>/dev/null || true
    
    # Also remove hash-prefixed containers directly via docker (handles edge cases)
    local hash_prefixed=$(docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "_${container_name}$|^[0-9a-f]+_${container_name}$" | awk '{print $1}')
    if [ -n "$hash_prefixed" ]; then
        echo "Removing hash-prefixed containers to avoid docker-compose issues..."
        echo "$hash_prefixed" | while read -r container_id; do
            docker rm -f "$container_id" 2>/dev/null || true
        done
    fi
    
    # Remove container by exact name if it exists
    docker rm -f "$container_name" 2>/dev/null || true
    
    echo "Starting service: $service..."
    
    # Check for .env file if needed (for services that require it)
    if [ ! -f .env ] && [ "$service" = "open-webui" ] || [ "$service" = "postgres" ] || [ "$service" = "pgadmin" ]; then
        if [ -f .env.example ]; then
            echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
            cp .env.example .env
            load_env_file ".env"
        else
            echo "‚ùå Error: .env file required for service '$service'"
            return 1
        fi
    fi
    
    # Generate pgAdmin configuration if starting pgadmin
    if [ "$service" = "pgadmin" ]; then
        generate_pgadmin_config
    fi
    
    # Start the specific service
    # Use --force-recreate if explicitly requested (e.g., after a rebuild)
    if [ "$force_recreate" = "true" ]; then
        if run_compose up -d --force-recreate --no-deps "$service"; then
            echo "‚úÖ Successfully started service: $service (recreated)"
        else
            echo "‚ùå Failed to start service: $service"
            return 1
        fi
    else
        if run_compose up -d "$service"; then
            echo "‚úÖ Successfully started service: $service"
        else
            echo "‚ùå Failed to start service: $service"
            return 1
        fi
    fi
    
    # Wait a moment for the service to initialize
    sleep 2
    
    # Check if the container is actually running (handle both exact name and hash-prefixed names)
    if docker ps --format "{{.Names}}" | grep -qE "^${container_name}$|_[0-9a-f]+_${container_name}$|^[0-9a-f]+_${container_name}$"; then
        echo "Service '$service' is now running."
    else
        echo "‚ö†Ô∏è  Service '$service' may not have started correctly. Check logs with: $0 logs $service"
    fi
    return 0
}

function stop_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service stop <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local service="$1"
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Check if service is running
    if ! docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Service '$service' is not running."
        return 0
    fi
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping service: $service..."
    
    # Stop the specific service
    if run_compose stop "$service"; then
        echo "‚úÖ Successfully stopped service: $service"
        
        # Clean up pgAdmin configuration if stopping pgadmin
        if [ "$service" = "pgadmin" ] && [ -f "pgadmin-servers.json" ]; then
            rm -f pgadmin-servers.json
            echo "üßπ Cleaned up pgAdmin configuration file"
        fi
        return 0
    else
        echo "‚ùå Failed to stop service: $service"
        return 1
    fi
}

function needs_rebuild() {
    local service="$1"
    
    # Services that require builds (have build context in docker-compose.yml)
    case "$service" in
        "llm-council")
            local build_context="${SCRIPT_DIR}/llm-council"
            local dockerfile="${build_context}/Dockerfile"
            
            if [ ! -d "$build_context" ] || [ ! -f "$dockerfile" ]; then
                return 1  # Can't determine, assume no rebuild needed
            fi
            
            # Check if image exists
            if ! docker images --format "{{.Repository}}:{{.Tag}}" 2>/dev/null | grep -q "^llm-council:latest$"; then
                return 0  # Image doesn't exist, needs build
            fi
            
            # Get image creation timestamp (Unix epoch)
            local image_timestamp=$(docker inspect --format='{{.Created}}' llm-council:latest 2>/dev/null)
            if [ -z "$image_timestamp" ]; then
                return 0  # Can't inspect image, rebuild to be safe
            fi
            
            # Convert image creation time to Unix timestamp
            local image_epoch=$(date -d "$image_timestamp" +%s 2>/dev/null || echo "0")
            if [ "$image_epoch" -eq 0 ]; then
                # Try alternative date parsing (for different date formats)
                image_epoch=$(date -d "$(echo "$image_timestamp" | sed 's/T/ /' | cut -d. -f1)" +%s 2>/dev/null || echo "0")
            fi
            
            # Check if any critical source files are newer than the image
            # Check Python files in backend directory (most likely to change)
            local backend_dir="${build_context}/backend"
            if [ -d "$backend_dir" ]; then
                # Find the most recently modified Python file
                local latest_py=$(find "$backend_dir" -type f -name "*.py" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
                if [ -n "$latest_py" ] && [ -f "$latest_py" ]; then
                    local file_epoch=$(stat -c %Y "$latest_py" 2>/dev/null || echo "0")
                    if [ "$file_epoch" -gt "$image_epoch" ]; then
                        return 0  # Source file is newer than image, needs rebuild
                    fi
                fi
            fi
            
            # Check Dockerfile
            if [ -f "$dockerfile" ]; then
                local dockerfile_epoch=$(stat -c %Y "$dockerfile" 2>/dev/null || echo "0")
                if [ "$dockerfile_epoch" -gt "$image_epoch" ]; then
                    return 0  # Dockerfile is newer than image, needs rebuild
                fi
            fi
            
            # Check pyproject.toml
            local pyproject="${build_context}/pyproject.toml"
            if [ -f "$pyproject" ]; then
                local pyproject_epoch=$(stat -c %Y "$pyproject" 2>/dev/null || echo "0")
                if [ "$pyproject_epoch" -gt "$image_epoch" ]; then
                    return 0  # pyproject.toml is newer than image, needs rebuild
                fi
            fi
            
            return 1  # No rebuild needed
            ;;
        *)
            # Other services don't require builds (use pre-built images)
            return 1
            ;;
    esac
}

function service() {
    if [[ $# -lt 2 ]]; then
        echo "Error: Service action and name are required"
        echo "Usage: $0 service {start|stop|restart} <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local action="$1"
    local service="$2"
    
    case "$action" in
        start)
            start_service "$service"
            ;;
        stop)
            stop_service "$service"
            ;;
        restart)
            echo "Restarting service: $service..."
            
            # Set up compose command early
            set_compose_cmd
            
            # Check if service needs rebuild
            if needs_rebuild "$service"; then
                echo "üî® Source code changes detected. Rebuilding $service..."
                
                # Stop and remove the service completely to avoid ContainerConfig errors
                stop_service "$service" 2>/dev/null || true
                
                # Force remove any existing containers (including hash-prefixed ones)
                echo "Removing existing containers for clean rebuild..."
                run_compose rm -f "$service" 2>/dev/null || true
                local container_name=$(get_container_name "$service")
                docker rm -f "$container_name" 2>/dev/null || true
                # Remove any hash-prefixed containers
                docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "_${container_name}$|^[0-9a-f]+_${container_name}$" | awk '{print $1}' | xargs -r docker rm -f 2>/dev/null || true
                
                # Rebuild the service
                echo "Building $service..."
                if run_compose build "$service"; then
                    echo "‚úÖ Successfully rebuilt $service"
                else
                    echo "‚ùå Failed to rebuild $service"
                    return 1
                fi
                
                # Start with force recreate after rebuild
                start_service "$service" "true"
            else
                # Just stop without rebuild
                stop_service "$service"
                sleep 2
                start_service "$service"
            fi
            ;;
        *)
            echo "Error: Unknown service action '$action'"
            echo "Available actions: start, stop, restart"
            return 1
            ;;
    esac
}

function logs() {
    if [ $# -eq 0 ]; then
        echo "Fetching logs for all services (following)..."
        echo "Press Ctrl+C to stop"
        echo ""
        
        # Check if any containers are running
        local services=("ollama" "open-webui" "postgres" "pgadmin" "llm-council" "watchtower" "prometheus" "grafana" "cadvisor" "node-exporter" "postgres-exporter" "nvidia-gpu-exporter" "loki" "promtail")
        local found_any=false
        local running_containers=()
        
        for service in "${services[@]}"; do
            # Check for exact match or hash-prefixed match
            if docker ps --format "{{.Names}}" 2>/dev/null | grep -qE "^${service}$|_[0-9a-f]+_${service}$|^[0-9a-f]+_${service}$"; then
                found_any=true
                running_containers+=("$service")
            fi
        done
        
        if [ "$found_any" = false ]; then
            echo "‚ö†Ô∏è  No services are currently running."
            echo "   Start services with: ./aixcl start"
            return 0
        fi
        
        # Use docker logs directly for each running container
        # Show last 100 lines then follow for each container
        for service in "${running_containers[@]}"; do
            echo "=== $service ==="
            docker logs "$service" --tail=100 2>/dev/null || echo "  (no logs available)"
            echo ""
        done
        
        echo "Following new logs (Press Ctrl+C to stop)..."
        echo ""
        
        # Follow logs from all containers in parallel using background processes
        local pids=()
        for service in "${running_containers[@]}"; do
            (
                docker logs "$service" --follow 2>/dev/null | while IFS= read -r line; do
                    echo "[$service] $line"
                done
            ) &
            pids+=($!)
        done
        
        # Wait for all background processes
        wait "${pids[@]}"
    else
        local container="$1"
        local tail_count="${2:-50}"  # Default to 50 lines if not specified
        
        # Validate tail_count
        if [[ ! "$tail_count" =~ ^[0-9]+$ ]] || [[ "$tail_count" -lt 1 ]] || [[ "$tail_count" -gt 10000 ]]; then
            echo "‚ùå tail count must be a number between 1 and 10000"
            return 1
        fi
        
        # Validate container name and find actual container (handle hash-prefixed names)
        case "$container" in
            ollama|open-webui|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter|loki|promtail)
                echo "Fetching logs for $container..."
                # Try exact name first, then hash-prefixed name
                local actual_container
                actual_container=$(docker ps --format "{{.Names}}" 2>/dev/null | grep -E "^${container}$|_[0-9a-f]+_${container}$|^[0-9a-f]+_${container}$" | head -1)
                if [ -n "$actual_container" ]; then
                    docker logs "$actual_container" --tail="$tail_count" --follow
                else
                    # Try stopped containers too
                    actual_container=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "^${container}$|_[0-9a-f]+_${container}$|^[0-9a-f]+_${container}$" | head -1)
                    if [ -n "$actual_container" ]; then
                        docker logs "$actual_container" --tail="$tail_count" --follow
                    else
                        echo "Error: Container '$container' not found (checked for exact name and hash-prefixed variants)"
                        return 1
                    fi
                fi
                ;;
            *)
                echo "Error: Unknown container '$container'"
                echo "Available containers: ollama, open-webui, postgres, pgadmin, llm-council, watchtower, prometheus, grafana, cadvisor, node-exporter, postgres-exporter, nvidia-gpu-exporter, loki, promtail"
                return 1
                ;;
        esac
    fi
}

function clean() {
    echo "Cleaning up Docker resources..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping all containers..."
    run_compose down
    
    # Remove postgres container and associated volumes specifically
    if docker ps -a --format "{{.Names}}" | grep -q "^postgres$"; then
        echo "Removing PostgreSQL container..."
        docker rm -f postgres 2>/dev/null || true
    fi
    
    # Remove postgres-related volumes
    echo "Removing PostgreSQL volumes..."
    docker volume ls --format "{{.Name}}" | grep -i postgres | while read -r volume; do
        if [ -n "$volume" ]; then
            echo "  Removing volume: $volume"
            docker volume rm "$volume" 2>/dev/null || true
        fi
    done
    
    echo "Removing stopped containers..."
    docker container prune -f
    
    echo "Removing unused images..."
    docker image prune -a -f
    
    echo "Removing unused volumes..."
    docker volume prune -f
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
    
    echo "Clean up complete."
}

function status() {
    echo "Checking services status..."
    echo ""
    
    # Core Application Services
    echo "Core"
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "  ‚úÖ Ollama"
    else
        echo "  ‚ùå Ollama"
    fi
    
    if docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "  ‚úÖ Open WebUI"
    else
        echo "  ‚ùå Open WebUI"
    fi

    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "  ‚úÖ LLM-Council"
    else
        echo "  ‚ùå LLM-Council"
    fi

    # Database Services
    echo ""
    echo "Data"
    if docker ps --format "{{.Names}}" | grep -q "postgres"; then
        echo "  ‚úÖ PostgreSQL"
    else
        echo "  ‚ùå PostgreSQL"
    fi

    if docker ps --format "{{.Names}}" | grep -q "pgadmin"; then
        echo "  ‚úÖ pgAdmin"
    else
        echo "  ‚ùå pgAdmin"
    fi

    # Monitoring Services
    echo ""
    echo "Monitoring"
    if docker ps --format "{{.Names}}" | grep -q "prometheus"; then
        echo "  ‚úÖ Prometheus"
    else
        echo "  ‚ùå Prometheus"
    fi

    if docker ps --format "{{.Names}}" | grep -q "grafana"; then
        echo "  ‚úÖ Grafana"
    else
        echo "  ‚ùå Grafana"
    fi

    if docker ps --format "{{.Names}}" | grep -q "cadvisor"; then
        echo "  ‚úÖ cAdvisor"
    else
        echo "  ‚ùå cAdvisor"
    fi

    if docker ps --format "{{.Names}}" | grep -q "node-exporter"; then
        echo "  ‚úÖ Node Exporter"
    else
        echo "  ‚ùå Node Exporter"
    fi

    if docker ps --format "{{.Names}}" | grep -q "postgres-exporter"; then
        echo "  ‚úÖ Postgres Exporter"
    else
        echo "  ‚ùå Postgres Exporter"
    fi

    if docker ps --format "{{.Names}}" | grep -q "nvidia-gpu-exporter"; then
        echo "  ‚úÖ NVIDIA GPU Exporter"
    else
        echo "  ‚ö†Ô∏è  NVIDIA GPU Exporter (expected on non-GPU systems)"
    fi

    # Logging Services
    echo ""
    echo "Logging"
    if docker ps --format "{{.Names}}" | grep -q "loki"; then
        echo "  ‚úÖ Loki"
    else
        echo "  ‚ùå Loki"
    fi

    if docker ps --format "{{.Names}}" | grep -q "promtail"; then
        echo "  ‚úÖ Promtail"
    else
        echo "  ‚ùå Promtail"
    fi

    # Utility Services
    echo ""
    echo "Utility"
    if docker ps --format "{{.Names}}" | grep -q "watchtower"; then
        echo "  ‚úÖ Watchtower"
    else
        echo "  ‚ùå Watchtower"
    fi
    
    echo ""
    echo "Service Health"
    echo ""
    
    # Core Application Services
    echo "Core"
    if curl -s -o /dev/null -w "%{http_code}" http://localhost:11434/api/version 2>/dev/null | grep -q "200"; then
        echo "  ‚úÖ Ollama"
    else
        echo "  ‚ùå Ollama"
    fi
    
    WEBUI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null || echo "000")
    if [ "$WEBUI_STATUS" = "200" ]; then
        echo "  ‚úÖ Open WebUI"
    else
        echo "  ‚ùå Open WebUI"
        echo "    Checking container logs (last 3 lines):"
        timeout 2 docker logs "$CONTAINER_NAME" --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
    fi

    COUNCIL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null || echo "000")
    if [ "$COUNCIL_STATUS" = "200" ]; then
        echo "  ‚úÖ LLM-Council"
    else
        echo "  ‚ùå LLM-Council"
        echo "    Checking LLM-Council logs (last 3 lines):"
        timeout 2 docker logs llm-council --tail 3 2>/dev/null || echo "    (Logs unavailable or container may not be running)"
    fi

    # Database Services
    echo ""
    echo "Data"
    if timeout 2 docker exec postgres pg_isready -U "${POSTGRES_USER:-webui}" >/dev/null 2>&1; then
        echo "  ‚úÖ PostgreSQL"
    else
        echo "  ‚ùå PostgreSQL"
        echo "    Checking PostgreSQL logs (last 3 lines):"
        timeout 2 docker logs postgres --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
    fi

    PGADMIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null || echo "000")
    if [ "$PGADMIN_STATUS" = "200" ] || [ "$PGADMIN_STATUS" = "302" ]; then
        echo "  ‚úÖ pgAdmin"
    else
        echo "  ‚ùå pgAdmin"
        echo "    Checking pgAdmin logs (last 3 lines):"
        timeout 2 docker logs pgadmin --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
    fi

    # Monitoring Services
    echo ""
    echo "Monitoring"
    PROMETHEUS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9090/-/healthy 2>/dev/null || echo "000")
    if [ "$PROMETHEUS_STATUS" = "200" ]; then
        echo "  ‚úÖ Prometheus"
    else
        echo "  ‚ùå Prometheus"
    fi

    GRAFANA_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null || echo "000")
    if [ "$GRAFANA_STATUS" = "200" ]; then
        echo "  ‚úÖ Grafana"
    else
        echo "  ‚ùå Grafana"
    fi

    CADVISOR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/metrics 2>/dev/null)
    if [ "$CADVISOR_STATUS" = "200" ]; then
        echo "  ‚úÖ cAdvisor"
    else
        echo "  ‚ùå cAdvisor"
    fi

    NODE_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9100/metrics 2>/dev/null)
    if [ "$NODE_EXPORTER_STATUS" = "200" ]; then
        echo "  ‚úÖ Node Exporter"
    else
        echo "  ‚ùå Node Exporter"
    fi

    POSTGRES_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9187/metrics 2>/dev/null)
    if [ "$POSTGRES_EXPORTER_STATUS" = "200" ]; then
        echo "  ‚úÖ Postgres Exporter"
    else
        echo "  ‚ùå Postgres Exporter"
    fi

    if docker ps --format "{{.Names}}" | grep -q "^nvidia-gpu-exporter$"; then
        NVIDIA_GPU_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9400/metrics 2>/dev/null)
        if [ "$NVIDIA_GPU_EXPORTER_STATUS" = "200" ]; then
            echo "  ‚úÖ NVIDIA GPU Exporter"
        else
            echo "  ‚ùå NVIDIA GPU Exporter"
        fi
    else
        echo "  ‚ö†Ô∏è  NVIDIA GPU Exporter (expected on non-GPU systems)"
    fi

    # Logging Services
    echo ""
    echo "Logging"
    if docker ps --format "{{.Names}}" | grep -q "^loki$"; then
        LOKI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3100/ready 2>/dev/null || echo "000")
        if [ "$LOKI_STATUS" = "200" ]; then
            echo "  ‚úÖ Loki"
        elif [ "$LOKI_STATUS" = "503" ]; then
            echo "  ‚ö†Ô∏è  Loki (starting up)"
        elif [ "$LOKI_STATUS" = "000" ]; then
            echo "  ‚ùå Loki"
            echo "    Checking Loki logs (last 3 lines):"
            timeout 2 docker logs loki --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
        else
            echo "  ‚ùå Loki"
            echo "    Checking Loki logs (last 3 lines):"
            timeout 2 docker logs loki --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
        fi
    else
        echo "  ‚ùå Loki"
    fi

    if docker ps --format "{{.Names}}" | grep -q "^promtail$"; then
        if docker exec promtail wget --no-verbose --tries=1 --spider http://localhost:9080/ready 2>/dev/null; then
            echo "  ‚úÖ Promtail"
        else
            echo "  ‚ùå Promtail"
        fi
    else
        echo "  ‚ùå Promtail"
    fi

    # Utility Services
    echo ""
    echo "Utility"
    if docker ps --format "{{.Names}}" | grep -q "^watchtower$"; then
        echo "  ‚úÖ Watchtower"
    else
        echo "  ‚ùå Watchtower"
    fi
    echo ""
}

function add() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models add <model-name> [<model-name> ...]"
        echo "Example: $0 models add starcoder2:latest"
        echo "Example: $0 models add starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Adding model: $1"
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec "$ollama_container" ollama pull "$1"; then
        echo "‚úÖ Successfully added model: $1"
    else
        echo "‚ùå Failed to add model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function remove() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models remove <model-name> [<model-name> ...]"
        echo "Example: $0 models remove starcoder2:latest"
        echo "Example: $0 models remove starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Removing model: $1"
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec "$ollama_container" ollama rm "$1"; then
        echo "‚úÖ Successfully removed model: $1"
    else
        echo "‚ùå Failed to remove model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function models() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Models action is required"
        echo "Usage: $0 models {add|remove|list} [<model-name> ...]"
        echo "Examples:"
        echo "  $0 models add starcoder2:latest"
        echo "  $0 models remove starcoder2:latest nomic-embed-text:latest"
        echo "  $0 models list"
        return 1
    fi

    local action="$1"
    shift

    local status=0

    case "$action" in
        add)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for add"
                echo "Usage: $0 models add <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! add "$model"; then
                    status=1
                fi
            done
            ;;
        remove)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for remove"
                echo "Usage: $0 models remove <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! remove "$model"; then
                    status=1
                fi
            done
            ;;
        list)
            if [[ $# -gt 0 ]]; then
                echo "Warning: Ignoring extra arguments for 'models list'"
            fi
            list
            ;;
        *)
            echo "Error: Unknown models action '$action'"
            echo "Available actions: add, remove, list"
            return 1
            ;;
    esac

    return $status
}

function list() {
    echo "Listing installed models..."
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    docker exec "$ollama_container" ollama list
}

function open_url_in_browser() {
    local url="$1"

    if command -v xdg-open &> /dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open &> /dev/null; then
        open "$url" 2>/dev/null &
    else
        echo "‚ö†Ô∏è  Could not detect default browser. Please open $url manually."
    fi
}

function dashboard_grafana() {
    echo "Opening Grafana monitoring dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "grafana"; then
        echo "‚ùå Grafana container is not running. Please start the services first."
        return 1
    fi

    # Check if Grafana is responding
    if ! curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null | grep -q "200"; then
        echo "‚ùå Grafana is not responding yet. Please wait for it to start."
        return 1
    fi

    local url="http://localhost:3000"
    echo "Grafana is available at: $url"
    echo "Default credentials: admin / admin (change on first login)"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_openwebui() {
    echo "Opening Open WebUI dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "‚ùå Open WebUI container is not running. Please start the services first."
        return 1
    fi

    local health_status
    health_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null || echo "000")

    if [ "$health_status" != "200" ]; then
        echo "‚ùå Open WebUI is not responding yet (HTTP $health_status). Please wait for it to start."
        return 1
    fi

    local url="http://localhost:8080"
    echo "Open WebUI is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_pgadmin() {
    echo "Opening pgAdmin dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "pgadmin"; then
        echo "‚ùå pgAdmin container is not running. Please start the services first."
        return 1
    fi

    local pgadmin_status
    pgadmin_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null || echo "000")

    case "$pgadmin_status" in
        200|302)
            ;;
        *)
            echo "‚ùå pgAdmin is not responding yet (HTTP $pgadmin_status). Please wait for it to start."
            return 1
            ;;
    esac

    local url="http://localhost:5050"
    echo "pgAdmin is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Missing dashboard target."
        echo "Usage: $0 dashboard {openwebui|grafana|pgadmin}"
        return 1
    fi

    case "$1" in
        grafana)
            dashboard_grafana
            ;;
        openwebui|open-webui|open_webui)
            dashboard_openwebui
            ;;
        pgadmin)
            dashboard_pgadmin
            ;;
        *)
            echo "Error: Unknown dashboard target '$1'"
            echo "Available targets: grafana, openwebui, pgadmin"
            return 1
            ;;
    esac
}

function help_menu() {
    echo "Usage: ./aixcl <cmd> [options]"
    echo ""
    echo "Stack: stack <action> (start | stop | restart | status | logs | clean)"
    echo "Service: service <action> <name>"
    echo "Models: models <action> [name]"
    echo "Council: council <action>"
    echo "Dashboard: dashboard <name>"
    echo "Utils: utils <action> (check-env | bash-completion)"
    echo "Direct: check-env | bash-completion | help"
    exit 1
}

function install_completion() {
    echo "Installing bash completion for aixcl..."
    echo "Cleaning up any existing completion files..."
    
    # Get the script directory (already set globally)
    # SCRIPT_DIR and COMPLETION_SCRIPT are already defined at script startup
    
    if [[ ! -f "$COMPLETION_SCRIPT" ]]; then
        echo "Error: Completion script not found at $COMPLETION_SCRIPT"
        exit 1
    fi
    
    # Clean up existing completion files
    local cleanup_dirs=(
        "$HOME/.local/share/bash-completion/completions"
        "/etc/bash_completion.d"
    )
    
    for dir in "${cleanup_dirs[@]}"; do
        if [[ -f "$dir/aixcl" ]]; then
            echo "Removing existing completion file: $dir/aixcl"
            rm -f "$dir/aixcl"
        fi
    done
    
    # Clean up .bashrc - remove any old aixcl completion references
    if [[ -f "$HOME/.bashrc" ]]; then
        echo "Cleaning up .bashrc..."
        local temp_bashrc="$(mktemp)"
        # Remove the entire completion block using sed
        # Pattern: from "Added by aixcl installer" through the next standalone "fi"
        sed '/Added by aixcl installer/,/^[[:space:]]*fi[[:space:]]*$/d' "$HOME/.bashrc" > "$temp_bashrc" || cp "$HOME/.bashrc" "$temp_bashrc"
        
        # Also remove any broken if/fi pairs where if contains aixcl but source was already removed
        # This handles the case where only "if ... then" and "fi" remain
        awk '
            BEGIN { prev_line = ""; prev_prev_line = "" }
            {
                # Check if current line is "fi" and previous was an empty if statement for aixcl
                if (/^[[:space:]]*fi[[:space:]]*$/) {
                    if (prev_line ~ /^[[:space:]]*if[[:space:]]+\[.*aixcl.*\][[:space:]]*;[[:space:]]*then[[:space:]]*$/) {
                        # This is an empty if/fi block for aixcl, skip both
                        prev_line = ""
                        prev_prev_line = ""
                        next
                    } else {
                        # Normal fi, keep it
                        if (prev_prev_line != "") print prev_prev_line
                        if (prev_line != "") print prev_line
                        print $0
                        prev_prev_line = ""
                        prev_line = ""
                        next
                    }
                }
                # Not a fi, so print previous lines if we have them
                if (prev_prev_line != "") {
                    print prev_prev_line
                    prev_prev_line = ""
                }
                if (prev_line != "") {
                    prev_prev_line = prev_line
                }
                prev_line = $0
            }
            END {
                if (prev_prev_line != "") print prev_prev_line
                if (prev_line != "") print prev_line
            }
        ' "$temp_bashrc" > "${temp_bashrc}.2" || cp "$temp_bashrc" "${temp_bashrc}.2"
        mv "${temp_bashrc}.2" "$temp_bashrc"
        
        # Only replace if we actually removed something or if file is different
        if ! cmp -s "$HOME/.bashrc" "$temp_bashrc"; then
            cp "$HOME/.bashrc" "$HOME/.bashrc.backup.$(date +%s)" 2>/dev/null || true
            mv "$temp_bashrc" "$HOME/.bashrc"
            echo "Cleaned up old completion references from .bashrc"
        else
            rm -f "$temp_bashrc"
        fi
    fi
    
    # Determine the appropriate completion directory
    if [[ -d "/etc/bash_completion.d" ]] && [[ -w "/etc/bash_completion.d" ]]; then
        # System-wide installation (requires write permission)
        COMPLETION_DIR="/etc/bash_completion.d"
    elif [[ -d "$HOME/.local/share/bash-completion/completions" ]]; then
        # User-specific installation (preferred)
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
    else
        # Create user directory if it doesn't exist
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
        mkdir -p "$COMPLETION_DIR"
    fi
    
    # Copy the completion script
    cp "$COMPLETION_SCRIPT" "$COMPLETION_DIR/aixcl"
    chmod +x "$COMPLETION_DIR/aixcl"
    
    echo "‚úÖ Bash completion installed to $COMPLETION_DIR/aixcl"
    echo ""
    echo "To use it immediately in this shell, run:"
    echo "  source $COMPLETION_DIR/aixcl"
    echo ""
    echo "Or restart your shell. It will be automatically loaded in new shell sessions."
    echo ""
    
    # Add to .bashrc
    local bashrc_entry="# Added by aixcl installer
if [ -f \"$COMPLETION_DIR/aixcl\" ]; then
    source \"$COMPLETION_DIR/aixcl\"
fi"
    
    if ! grep -q "Added by aixcl installer" "$HOME/.bashrc" 2>/dev/null; then
        echo "" >> "$HOME/.bashrc"
        echo "$bashrc_entry" >> "$HOME/.bashrc"
        echo "Added sourcing to ~/.bashrc for persistent completion"
    else
        echo "Completion script already referenced in ~/.bashrc"
    fi
}

function get_available_models() {
    # Get list of available models from Ollama
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running. Please start the services first."
        return 1
    fi
    
    # Get models list, skip header line, extract model names
    local ollama_container
    ollama_container=$(get_ollama_container)
    if [ -n "$ollama_container" ]; then
        docker exec "$ollama_container" ollama list 2>/dev/null | awk 'NR>1 {print $1}' | grep -v "^$"
    fi
}

function update_env_file() {
    local council_models="$1"
    local chairman_model="$2"
    local env_file=".env"
    
    # Check if .env file exists
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found. Please run './aixcl start' first to create it."
        return 1
    fi
    
    # Create backup
    cp "$env_file" "${env_file}.backup.$(date +%s)"
    
    # Remove all existing COUNCIL_MODELS lines (including commented ones)
    # This ensures we completely overwrite any existing configuration
    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS uses BSD sed
        sed -i '' '/^[[:space:]]*#.*COUNCIL_MODELS/d' "$env_file"
        sed -i '' '/^COUNCIL_MODELS=/d' "$env_file"
        # Remove all existing CHAIRMAN_MODEL lines
        sed -i '' '/^[[:space:]]*#.*CHAIRMAN_MODEL/d' "$env_file"
        sed -i '' '/^CHAIRMAN_MODEL=/d' "$env_file"
        # Add new values at the end
        echo "COUNCIL_MODELS=${council_models}" >> "$env_file"
        echo "CHAIRMAN_MODEL=${chairman_model}" >> "$env_file"
    else
        # Linux uses GNU sed
        sed -i '/^[[:space:]]*#.*COUNCIL_MODELS/d' "$env_file"
        sed -i '/^COUNCIL_MODELS=/d' "$env_file"
        # Remove all existing CHAIRMAN_MODEL lines
        sed -i '/^[[:space:]]*#.*CHAIRMAN_MODEL/d' "$env_file"
        sed -i '/^CHAIRMAN_MODEL=/d' "$env_file"
        # Add new values at the end
        echo "COUNCIL_MODELS=${council_models}" >> "$env_file"
        echo "CHAIRMAN_MODEL=${chairman_model}" >> "$env_file"
    fi
    
    echo "‚úÖ Updated .env file with council configuration"
    return 0
}

function status_council() {
    echo "üìã LLM Council Status"
    echo "===================="
    echo ""
    
    # Check if services are running
    local llm_council_running=false
    local ollama_running=false
    
    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        llm_council_running=true
    fi
    
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        ollama_running=true
    fi
    
    # Read configuration from .env file
    local council_models=""
    local chairman_model=""
    local backend_mode="ollama"
    local env_file=".env"
    
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found."
        echo "   Please run './aixcl start' first to create it, then configure the council with './aixcl council configure'"
        return 1
    fi
    
    # Read .env file
    while IFS= read -r line || [ -n "$line" ]; do
        [[ -z "$line" ]] && continue
        [[ "${line#\#}" != "$line" ]] && continue
        
        if [[ "$line" =~ ^BACKEND_MODE[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            backend_mode="${BASH_REMATCH[1]}"
            backend_mode=$(echo "$backend_mode" | xargs | tr -d '"' | tr -d "'")
        elif [[ "$line" =~ ^COUNCIL_MODELS[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            council_models="${BASH_REMATCH[1]}"
            council_models=$(echo "$council_models" | xargs | tr -d '"' | tr -d "'")
        elif [[ "$line" =~ ^CHAIRMAN_MODEL[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            chairman_model="${BASH_REMATCH[1]}"
            chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
        fi
    done < "$env_file"
    
    echo "Configuration:"
    echo "  Backend Mode: ${backend_mode:-ollama}"
    echo ""
    echo "  Chairman: ${chairman_model:-<not set>}"
    echo "  Council Members: ${council_models:-<not set>}"
    echo ""
    
    # Check if council is configured
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "‚ö†Ô∏è  Council is not configured yet."
        echo ""
        echo "To configure the council, run:"
        echo "  ./aixcl council configure"
        return 0
    fi
    
    # Clean up values
    council_models=$(echo "$council_models" | xargs | tr -d '"' | tr -d "'")
    chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
    
    # Build list of all models (avoid duplicates) - use the config we determined above
    local all_models=()
    local seen_models=()
    
    # Add council members
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs | tr -d '"' | tr -d "'")
            if [[ -n "$member" ]]; then
                local already_added=false
                for seen in "${seen_models[@]}"; do
                    if [[ "$seen" == "$member" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ "$already_added" == "false" ]]; then
                    all_models+=("$member")
                    seen_models+=("$member")
                fi
            fi
        done
    fi
    
    # Add chairman if not already in the list
    if [[ -n "$chairman_model" ]]; then
        local already_added=false
        for seen in "${seen_models[@]}"; do
            if [[ "$seen" == "$chairman_model" ]]; then
                already_added=true
                break
            fi
        done
        if [[ "$already_added" == "false" ]]; then
            all_models+=("$chairman_model")
        fi
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured"
        return 1
    fi
    
    # Test operational status for each model
    echo "Operational Status:"
    echo "-------------------"
    echo ""
    
    local operational_count=0
    local total_count=${#all_models[@]}
    
    for model in "${all_models[@]}"; do
        local role="Council Member"
        if [[ "$model" == "$chairman_model" ]]; then
            role="Chairman"
        fi
        
        echo -n "  $model ($role): "
        
        # Test if model is operational
        local is_operational=false
        local status_msg=""
        
        if [[ "$backend_mode" == "ollama" ]] && [[ "$ollama_running" == "true" ]]; then
            # Test model by sending a simple query to Ollama
            local test_payload
            test_payload=$(python3 -c "
import json
import sys
model = sys.argv[1]
payload = {
    'model': model,
    'messages': [{'role': 'user', 'content': 'Say OK'}],
    'stream': False
}
print(json.dumps(payload))
" "$model" 2>/dev/null)
            
            if [[ -n "$test_payload" ]]; then
                local response
                local status_code
                response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:11434/api/chat \
                    -H "Content-Type: application/json" \
                    -d "$test_payload" 2>/dev/null)
                
                status_code=$(echo "$response" | tail -n1)
                response_body=$(echo "$response" | sed '$d')
                
                if [[ "$status_code" == "200" ]] && echo "$response_body" | grep -q "message"; then
                    is_operational=true
                    operational_count=$((operational_count + 1))
                fi
            fi
        elif [[ "$backend_mode" != "ollama" ]]; then
            # For OpenRouter, assume operational (can't test without API key)
            is_operational=true
            operational_count=$((operational_count + 1))
            status_msg=" (OpenRouter - not tested)"
        fi
        
        if [[ "$is_operational" == "true" ]]; then
            echo "‚úÖ Operational$status_msg"
        else
            if [[ "$ollama_running" == "false" ]]; then
                echo "‚ö†Ô∏è  Cannot test (Ollama not running)"
            else
                echo "‚ùå Not Operational"
            fi
        fi
    done
    
    echo ""
    echo "Summary:"
    echo "  Total Models: $total_count"
    echo "  Operational: $operational_count"
    echo "  Not Operational: $((total_count - operational_count))"
    echo ""
    
    # Service status
    if [[ "$llm_council_running" == "true" ]]; then
        echo "‚úÖ LLM-Council service is running"
    else
        echo "‚ö†Ô∏è  LLM-Council service is not running"
    fi
    
    if [[ "$ollama_running" == "true" ]]; then
        echo "‚úÖ Ollama service is running"
    else
        echo "‚ö†Ô∏è  Ollama service is not running"
    fi
    echo ""
}

function list_council() {
    echo "üìã Current LLM Council Configuration"
    echo "===================================="
    echo ""
    
    local env_file=".env"
    
    # Check if .env file exists
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found."
        echo "   Please run './aixcl start' first to create it, then configure the council with './aixcl council configure'"
        return 1
    fi
    
    # Read directly from .env file to ensure we get the values
    # (Environment variables might not be available in function scope)
    local council_models=""
    local chairman_model=""
    
    # Read .env file line by line
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        [[ -z "$line" ]] && continue
        [[ "${line#\#}" != "$line" ]] && continue
        
        # Match COUNCIL_MODELS=value
        if [[ "$line" =~ ^COUNCIL_MODELS[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            council_models="${BASH_REMATCH[1]}"
            # Trim whitespace
            council_models=$(echo "$council_models" | xargs)
            # Remove surrounding quotes if present
            if [[ "$council_models" =~ ^\"(.*)\"$ ]]; then
                council_models="${BASH_REMATCH[1]}"
            elif [[ "$council_models" =~ ^\'(.*)\'$ ]]; then
                council_models="${BASH_REMATCH[1]}"
            fi
        # Match CHAIRMAN_MODEL=value
        elif [[ "$line" =~ ^CHAIRMAN_MODEL[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            chairman_model="${BASH_REMATCH[1]}"
            # Trim whitespace
            chairman_model=$(echo "$chairman_model" | xargs)
            # Remove surrounding quotes if present
            if [[ "$chairman_model" =~ ^\"(.*)\"$ ]]; then
                chairman_model="${BASH_REMATCH[1]}"
            elif [[ "$chairman_model" =~ ^\'(.*)\'$ ]]; then
                chairman_model="${BASH_REMATCH[1]}"
            fi
        fi
    done < "$env_file"
    
    # Check if council is configured
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "‚ö†Ô∏è  Council is not configured yet."
        echo ""
        echo "To configure the council, run:"
        echo "  ./aixcl council configure"
        return 0
    fi
    
    # Get available models from Ollama (if running)
    local available_models=""
    local can_check_models=false
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        available_models=$(get_available_models)
        if [[ -n "$available_models" ]]; then
            can_check_models=true
        fi
    fi
    
    # Helper function to check if a model exists
    model_exists() {
        local model_to_check="$1"
        if [[ "$can_check_models" == "true" ]]; then
            echo "$available_models" | grep -q "^${model_to_check}$"
        else
            return 1
        fi
    }
    
    # Display chairman with existence check
    echo "üëë Chairman Model:"
    if [[ -n "$chairman_model" ]]; then
        if model_exists "$chairman_model"; then
            echo "   ‚úÖ $chairman_model"
            echo "       Role: Chairman (primary decision maker)"
            echo "       Status: Available in Ollama"
        else
            if [[ "$can_check_models" == "true" ]]; then
                echo "   ‚ùå $chairman_model"
                echo "       Role: Chairman (primary decision maker)"
                echo "       Status: Not found in Ollama"
            else
                echo "   ‚ö†Ô∏è  $chairman_model"
                echo "       Role: Chairman (primary decision maker)"
                echo "       Status: Cannot verify (Ollama not running)"
            fi
        fi
    else
        echo "   ‚ö†Ô∏è  Not set"
    fi
    
    echo ""
    
    # Display council members with existence check
    echo "üë• Council Members:"
    
    if [[ -n "$council_models" ]]; then
        # Split comma-separated models
        IFS=',' read -ra MEMBERS <<< "$council_models"
        local member_count=0
        local existing_count=0
        
        # Display each member
        for member in "${MEMBERS[@]}"; do
            # Trim whitespace using bash native method
            member="${member#"${member%%[![:space:]]*}"}"  # Remove leading whitespace
            member="${member%"${member##*[![:space:]]}"}"  # Remove trailing whitespace
            if [[ -n "$member" ]]; then
                # Increment counter (use assignment to avoid set -e issues)
                member_count=$((member_count + 1))
                
                # Determine role - check if this member is also the chairman
                local role="Member"
                if [[ "$member" == "$chairman_model" ]]; then
                    role="Chairman (also listed as member)"
                fi
                
                # Query Ollama directly to verify the model exists
                local model_verified=false
                local ollama_running=false
                
                # Temporarily disable exit on error for docker commands
                set +e
                local ollama_container
                ollama_container=$(get_ollama_container)
                if [ -n "$ollama_container" ]; then
                    ollama_running=true
                    # Check if model exists in Ollama by querying directly
                    local ollama_models=""
                    ollama_models=$(docker exec "$ollama_container" ollama list 2>/dev/null | awk 'NR>1 {print $1}' 2>/dev/null)
                    if echo "$ollama_models" 2>/dev/null | grep -q "^${member}$" 2>/dev/null; then
                        model_verified=true
                    fi
                fi
                set -e
                
                # Display the member
                if [[ "$model_verified" == "true" ]]; then
                    echo "   [$member_count] ‚úÖ $member"
                    echo "       Role: $role"
                    echo "       Status: Verified in Ollama"
                    existing_count=$((existing_count + 1))
                elif [[ "$ollama_running" == "true" ]]; then
                    echo "   [$member_count] ‚ùå $member"
                    echo "       Role: $role"
                    echo "       Status: Not found in Ollama"
                else
                    echo "   [$member_count] ‚ö†Ô∏è  $member"
                    echo "       Role: $role"
                    echo "       Status: Cannot verify (Ollama not running)"
                fi
                echo ""
            fi
        done
        
        if [[ $member_count -eq 0 ]]; then
            echo "   ‚ö†Ô∏è  No members configured"
        else
            echo "   Total members: $member_count"
            if docker ps --format "{{.Names}}" | grep -q "ollama"; then
                if [[ $existing_count -eq $member_count ]]; then
                    echo "   ‚úÖ All $existing_count members are verified in Ollama"
                elif [[ $existing_count -lt $member_count ]]; then
                    echo "   ‚ö†Ô∏è  Only $existing_count of $member_count members are available in Ollama"
                fi
            fi
        fi
    else
        echo "   ‚ö†Ô∏è  Not set in .env file"
        echo "   (Expected format: COUNCIL_MODELS=model1,model2,model3)"
    fi
    
    echo ""
    
    # Calculate total models and existing models
    local total_models=0
    local existing_models=0
    if [[ -n "$chairman_model" ]]; then
        ((total_models++))
        if model_exists "$chairman_model"; then
            ((existing_models++))
        fi
    fi
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs)
            if [[ -n "$member" ]]; then
                ((total_models++))
                if model_exists "$member"; then
                    ((existing_models++))
                fi
            fi
        done
    fi
    
    echo "üìä Council Composition Summary:"
    echo "   Total models in council: $total_models"
    if [[ $total_models -gt 0 ]]; then
        echo "   - Chairman: 1 ($chairman_model)"
        if [[ -n "$council_models" ]]; then
            IFS=',' read -ra MEMBERS <<< "$council_models"
            local actual_member_count=0
            for member in "${MEMBERS[@]}"; do
                member=$(echo "$member" | xargs)
                [[ -n "$member" ]] && ((actual_member_count++))
            done
            echo "   - Members: $actual_member_count"
        else
            echo "   - Members: 0"
        fi
    fi
    if [[ "$can_check_models" == "true" ]]; then
        if [[ $existing_models -eq $total_models ]] && [[ $total_models -gt 0 ]]; then
            echo "   ‚úÖ All $existing_models models are available in Ollama"
        elif [[ $existing_models -lt $total_models ]]; then
            echo "   ‚ö†Ô∏è  Only $existing_models of $total_models models are available in Ollama"
        fi
    else
        echo "   ‚ö†Ô∏è  Cannot verify model availability (Ollama not running)"
    fi
    echo ""
    
    # Check if LLM-Council service is running
    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "‚úÖ LLM-Council service is running"
        echo ""
        if [[ "$can_check_models" == "true" ]] && [[ $existing_models -lt $total_models ]]; then
            echo "‚ö†Ô∏è  Warning: Some configured models are not available in Ollama."
            echo "   The council may not function correctly until all models are installed."
            echo ""
        else
            echo "üí° This configuration is active and will be used for the next request."
        fi
    else
        echo "‚ö†Ô∏è  LLM-Council service is not running"
        echo ""
        echo "üí° To apply this configuration:"
        echo "   1. Start services: ./aixcl start"
        echo "   2. Or restart LLM-Council: ./aixcl restart"
    fi
    
    echo ""
}

function test_council_operational() {
    echo "üß™ Testing LLM Council Member Operational Status"
    echo "=============================================="
    echo ""
    
    # Check if LLM-Council service is running
    if ! docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "‚ùå Error: LLM-Council service is not running."
        echo "   Please start the service first with: ./aixcl start"
        return 1
    fi
    
    # Check if Ollama is running
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running."
        echo "   Please start the services first with: ./aixcl start"
        return 1
    fi
    
    # Get configuration from API
    echo "1. Fetching council configuration from API..."
    local config_response
    config_response=$(curl -s http://localhost:8000/api/config 2>/dev/null)
    
    local council_models=""
    local chairman_model=""
    
    # Try to parse JSON using Python (more reliable than bash regex)
    if command -v python3 >/dev/null 2>&1 && [[ -n "$config_response" ]] && echo "$config_response" | grep -q "council_models"; then
        # Use Python to parse JSON properly
        council_models=$(echo "$config_response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    models = data.get('council_models', [])
    if isinstance(models, list):
        print(','.join(models))
    else:
        print('')
except:
    print('')
" 2>/dev/null)
        
        chairman_model=$(echo "$config_response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data.get('chairman_model', ''))
except:
    print('')
" 2>/dev/null)
    fi
    
    # Fallback to .env file if API parsing failed
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "   ‚ö†Ô∏è  Could not parse API response, reading from .env file..."
        
        local env_file=".env"
        if [[ ! -f "$env_file" ]]; then
            echo "   ‚ùå .env file not found"
            return 1
        fi
        
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            [[ "${line#\#}" != "$line" ]] && continue
            
            if [[ "$line" =~ ^COUNCIL_MODELS[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                council_models="${BASH_REMATCH[1]}"
                council_models=$(echo "$council_models" | xargs)
                if [[ "$council_models" =~ ^\"(.*)\"$ ]]; then
                    council_models="${BASH_REMATCH[1]}"
                elif [[ "$council_models" =~ ^\'(.*)\'$ ]]; then
                    council_models="${BASH_REMATCH[1]}"
                fi
            elif [[ "$line" =~ ^CHAIRMAN_MODEL[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                chairman_model="${BASH_REMATCH[1]}"
                chairman_model=$(echo "$chairman_model" | xargs)
                if [[ "$chairman_model" =~ ^\"(.*)\"$ ]]; then
                    chairman_model="${BASH_REMATCH[1]}"
                elif [[ "$chairman_model" =~ ^\'(.*)\'$ ]]; then
                    chairman_model="${BASH_REMATCH[1]}"
                fi
            fi
        done < "$env_file"
    fi
    
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "   ‚ùå No council configuration found"
        echo "   Please configure the council first with: ./aixcl council configure"
        return 1
    fi
    
    # Clean up extracted values
    council_models=$(echo "$council_models" | xargs)
    chairman_model=$(echo "$chairman_model" | xargs)
    
    echo "   ‚úÖ Configuration loaded"
    echo "   Council Models: $council_models"
    echo "   Chairman Model: $chairman_model"
    echo ""
    
    # Build list of all models to test (avoid duplicates)
    local all_models=()
    local seen_models=()
    
    # Add council members
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs | tr -d '"' | tr -d "'")
            if [[ -n "$member" ]]; then
                # Check if already added
                local already_added=false
                for seen in "${seen_models[@]}"; do
                    if [[ "$seen" == "$member" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ "$already_added" == "false" ]]; then
                    all_models+=("$member")
                    seen_models+=("$member")
                fi
            fi
        done
    fi
    
    # Add chairman if not already in the list
    if [[ -n "$chairman_model" ]]; then
        chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
        local already_added=false
        for seen in "${seen_models[@]}"; do
            if [[ "$seen" == "$chairman_model" ]]; then
                already_added=true
                break
            fi
        done
        if [[ "$already_added" == "false" ]]; then
            all_models+=("$chairman_model")
        fi
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured to test"
        return 1
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured to test"
        return 1
    fi
    
    echo "2. Testing ${#all_models[@]} model(s) with a simple query..."
    echo "   Models to test: ${all_models[*]}"
    echo ""
    
    local operational_count=0
    local total_count=${#all_models[@]}
    
    for model in "${all_models[@]}"; do
        local role="Council Member"
        if [[ "$model" == "$chairman_model" ]]; then
            role="Chairman"
        fi
        
        echo -n "   Testing $role: $model... "
        
        # Test model by sending a simple query to Ollama
        # Use Python to properly construct JSON payload to avoid escaping issues
        local test_payload
        test_payload=$(python3 -c "
import json
import sys
model = sys.argv[1]
payload = {
    'model': model,
    'messages': [{'role': 'user', 'content': 'Say OK'}],
    'stream': False
}
print(json.dumps(payload))
" "$model" 2>/dev/null)
        
        if [[ -z "$test_payload" ]]; then
            echo "‚ùå Not Operational"
            echo "      Error: Failed to create test payload"
            continue
        fi
        
        local response
        local status_code
        response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:11434/api/chat \
            -H "Content-Type: application/json" \
            -d "$test_payload" 2>/dev/null)
        
        status_code=$(echo "$response" | tail -n1)
        response_body=$(echo "$response" | sed '$d')
        
        if [[ "$status_code" == "200" ]] && echo "$response_body" | grep -q "message"; then
            echo "‚úÖ Operational"
            operational_count=$((operational_count + 1))
        else
            echo "‚ùå Not Operational"
            if [[ "$status_code" != "200" ]]; then
                echo "      HTTP Status: $status_code"
            fi
            if echo "$response_body" | grep -q "error"; then
                local error_msg
                error_msg=$(echo "$response_body" | grep -o '"error":"[^"]*"' | sed 's/"error":"\(.*\)"/\1/' | head -1)
                [[ -n "$error_msg" ]] && echo "      Error: $error_msg"
            fi
        fi
    done
    
    echo ""
    echo "=" | awk '{printf "=%.0s", $1; for(i=1;i<=65;i++) printf "="; print ""}'
    echo "Summary"
    echo "=" | awk '{printf "=%.0s", $1; for(i=1;i<=65;i++) printf "="; print ""}'
    echo "Total Models: $total_count"
    echo "Operational: $operational_count"
    echo "Not Operational: $((total_count - operational_count))"
    echo ""
    
    if [[ $operational_count -eq $total_count ]]; then
        echo "‚úÖ All council members are operational!"
        return 0
    else
        echo "‚ùå Some council members are not operational"
        echo ""
        echo "Please check:"
        echo "  - Are all models installed in Ollama? (./aixcl models list)"
        echo "  - Are models loaded and ready? (docker logs ollama)"
        echo "  - Check model names match exactly (including tags)"
        return 1
    fi
}

function configure_council() {
    echo "üîß Configuring LLM Council"
    echo "=========================="
    echo ""
    echo "Note: This will ignore any existing .env configuration and create a new one."
    echo ""
    
    # Check if Ollama is running
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running."
        echo "   Please start the services first with: ./aixcl start"
        return 1
    fi
    
    # Get available models
    echo "Fetching available models from Ollama..."
    local available_models
    available_models=$(get_available_models)
    
    if [[ -z "$available_models" ]]; then
        echo "‚ùå Error: No models found in Ollama."
        echo "   Please add models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Convert to array for easier handling
    local models_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && models_array+=("$line")
    done <<< "$available_models"
    
    local model_count=${#models_array[@]}
    
    if [[ $model_count -lt 2 ]]; then
        echo "‚ùå Error: At least 2 models are required for the council (1 chairman + 1 member)."
        echo "   You currently have $model_count model(s)."
        echo "   Please add more models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Display available models
    echo ""
    echo "Available models:"
    echo "-----------------"
    local index=1
    for model in "${models_array[@]}"; do
        echo "  [$index] $model"
        ((index++))
    done
    echo ""
    
    # Select chairman
    local chairman_index
    local chairman_model
    while true; do
        read -p "Select chairman model (1-$model_count): " chairman_index
        if [[ "$chairman_index" =~ ^[0-9]+$ ]] && [[ "$chairman_index" -ge 1 ]] && [[ "$chairman_index" -le $model_count ]]; then
            chairman_model="${models_array[$((chairman_index - 1))]}"
            echo "‚úÖ Selected chairman: $chairman_model"
            break
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count."
        fi
    done
    
    # Select council members (up to 4 more, for a total of 5)
    local council_members=()
    local max_members=4
    local current_count=0
    local min_members_required=1  # At least 1 member required (plus chairman = 2 total)
    
    echo ""
    echo "Select council members (at least 1 member required, up to $max_members more models):"
    echo "Note: Chairman is already included. Total council size will be 1 + number of members selected."
    echo ""
    
    # Disable exit on error for the interactive loop (we handle errors manually)
    set +e
    
    # Ensure we enter the loop
    while true; do
        local remaining=$((max_members - current_count))
        local total_selected=$((${#council_members[@]} + 1))  # +1 for chairman
        
        if [[ $total_selected -ge 5 ]]; then
            echo ""
            echo "‚úÖ Maximum of 5 models reached (1 chairman + ${#council_members[@]} members)."
            break
        fi
        
        echo ""
        echo "Currently selected:"
        echo "  Chairman: $chairman_model"
        if [[ ${#council_members[@]} -gt 0 ]]; then
            echo "  Members:"
            for member in "${council_members[@]}"; do
                echo "    - $member"
            done
        else
            echo "  Members: (none yet - at least 1 required)"
        fi
        echo ""
        echo "Available models:"
        local available_count=0
        local index=1
        for model in "${models_array[@]}"; do
            local is_selected=0
            local marker=""
            if [[ "$model" == "$chairman_model" ]]; then
                marker=" (chairman)"
                is_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$model" == "$member" ]]; then
                    marker=" (selected)"
                    is_selected=1
                    break
                fi
            done
            if [[ $is_selected -eq 0 ]]; then
                marker=""
                ((available_count++))
            fi
            echo "  [$index] $model$marker"
            ((index++))
        done
        
        if [[ $available_count -eq 0 ]]; then
            echo ""
            echo "  (no more models available)"
            break
        fi
        
        # Build prompt message
        local prompt_msg="Select model (1-$model_count)"
        if [[ ${#council_members[@]} -ge $min_members_required ]]; then
            prompt_msg="$prompt_msg, or 'done' to finish"
            if [[ $remaining -gt 0 ]]; then
                prompt_msg="$prompt_msg [$remaining remaining]"
            fi
        else
            local needed=$((min_members_required - ${#council_members[@]}))
            prompt_msg="$prompt_msg (at least $needed more required)"
        fi
        prompt_msg="$prompt_msg: "
        
        echo ""
        read -p "$prompt_msg" selection
        
        # Handle 'done' option - only allow if minimum members are selected
        if [[ "$selection" == "done" ]] || [[ "$selection" == "d" ]]; then
            if [[ ${#council_members[@]} -lt $min_members_required ]]; then
                local needed=$((min_members_required - ${#council_members[@]}))
                echo "‚ùå At least $needed more member(s) required. Please select more models."
                continue
            else
                echo "‚úÖ Finished selecting council members."
                break
            fi
        fi
        
        # Validate numeric selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $model_count ]]; then
            local selected_model="${models_array[$((selection - 1))]}"
            
            # Check if already selected
            local already_selected=0
            if [[ "$selected_model" == "$chairman_model" ]]; then
                already_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$selected_model" == "$member" ]]; then
                    already_selected=1
                    break
                fi
            done
            
            if [[ $already_selected -eq 1 ]]; then
                echo "‚ùå Model '$selected_model' is already selected. Please choose a different model."
            else
                council_members+=("$selected_model")
                echo "‚úÖ Added '$selected_model' to council members"
                ((current_count++))
            fi
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count"
            if [[ ${#council_members[@]} -ge $min_members_required ]]; then
                echo "   or type 'done' to finish."
            fi
        fi
    done
    
    # Re-enable exit on error
    set -e
    
    # Validate we have at least 2 models (chairman + at least 1 member)
    local total_models=$((${#council_members[@]} + 1))
    if [[ $total_models -lt 2 ]]; then
        echo ""
        echo "‚ùå Error: Council must have at least 2 models (1 chairman + 1 member)."
        echo "   You selected only the chairman."
        exit 1
    fi
    
    # Build council models string (comma-separated, excluding chairman)
    local council_models_str=""
    for member in "${council_members[@]}"; do
        if [[ -z "$council_models_str" ]]; then
            council_models_str="$member"
        else
            council_models_str="$council_models_str,$member"
        fi
    done
    
    # Show summary
    echo ""
    echo "=========================="
    echo "Council Configuration Summary"
    echo "=========================="
    echo "Chairman: $chairman_model"
    echo "Council Members (${#council_members[@]}):"
    for member in "${council_members[@]}"; do
        echo "  - $member"
    done
    echo "Total models: $total_models"
    echo ""
    echo "This will overwrite in .env file:"
    echo "  - COUNCIL_MODELS: $council_models_str"
    echo "  - CHAIRMAN_MODEL: $chairman_model"
    echo ""
    echo "‚ö†Ô∏è  Note: Any existing council configuration in .env will be replaced."
    echo ""
    
    # Ask for confirmation
    read -p "Apply this configuration? (yes/no): " confirm
    if [[ "$confirm" != "yes" ]] && [[ "$confirm" != "y" ]]; then
        echo "Configuration cancelled."
        exit 0
    fi
    
    # Update .env file for persistence (this will overwrite existing values)
    if ! update_env_file "$council_models_str" "$chairman_model"; then
        exit 1
    fi
    
    echo ""
    echo "‚úÖ Council configuration updated successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Restart the LLM-Council service to apply changes:"
    echo "     ./aixcl restart"
    echo "  2. The configuration will be loaded automatically"
    echo ""
    
    # Ask if user wants to restart services
    read -p "Restart LLM-Council service now? (yes/no): " restart_confirm
    if [[ "$restart_confirm" == "yes" ]] || [[ "$restart_confirm" == "y" ]]; then
        echo ""
        echo "Restarting LLM-Council service to apply new configuration..."
        set_compose_cmd
        # Stop if running
        if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
            run_compose stop llm-council 2>/dev/null || true
        fi
        # Always remove the container to avoid docker-compose ContainerConfig KeyError
        # when using images from registry (older docker-compose versions have this bug)
        # This also handles the case where container exists but is stopped
        run_compose rm -f llm-council 2>/dev/null || docker rm -f llm-council 2>/dev/null || true
        run_compose build llm-council
        run_compose up -d llm-council
        echo "‚úÖ LLM-Council service restarted with new configuration"
    fi
    exit 0
}

function utils_cmd() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Utils action is required"
        echo "Usage: $0 utils {check-env|bash-completion}"
        echo "Examples:"
        echo "  $0 utils check-env         - Verify environment setup"
        echo "  $0 utils bash-completion   - Install bash completion"
        return 1
    fi

    local action="$1"
    shift

    case "$action" in
        check-env)
            check_env
            ;;
        bash-completion)
            install_completion
            ;;
        *)
            echo "Error: Unknown utils action '$action'"
            echo "Usage: $0 utils {check-env|bash-completion}"
            echo "Examples:"
            echo "  $0 utils check-env         - Verify environment setup"
            echo "  $0 utils bash-completion   - Install bash completion"
            return 1
            ;;
    esac
}

function stack_cmd() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Stack action is required"
        echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
        echo "Examples:"
        echo "  $0 stack start         - Start all services"
        echo "  $0 stack stop          - Stop all services"
        echo "  $0 stack restart       - Restart the entire stack"
        echo "  $0 stack status        - Show service status"
        echo "  $0 stack logs          - Show logs for all services"
        echo "  $0 stack logs ollama   - Show logs for a specific service"
        echo "  $0 stack logs ollama 100 - Show last 100 lines for a service"
        echo "  $0 stack clean         - Remove unused Docker resources"
        return 1
    fi

    local action="$1"
    shift

    case "$action" in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            restart
            ;;
        status)
            status
            ;;
        logs)
            logs "$@"
            ;;
        clean)
            clean
            ;;
        *)
            echo "Error: Unknown stack action '$action'"
            echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
            return 1
            ;;
    esac
}

function council_cmd() {
    # Default to 'status' if no action is provided
    if [[ $# -lt 1 ]]; then
        status_council
        return 0
    fi

    local action="$1"
    shift

    case "$action" in
        configure)
            configure_council
            ;;
        status)
            status_council
            ;;
        *)
            echo "Error: Unknown council action '$action'"
            echo "Usage: $0 council [configure|status]"
            echo "Examples:"
            echo "  $0 council              - Show council status (default)"
            echo "  $0 council status      - Show council configuration and operational status"
            echo "  $0 council configure  - Configure council models and chairman"
            return 1
            ;;
    esac
}

function main() {
    if [[ $# -lt 1 ]]; then
        help_menu
    fi

    case "$1" in
        service)
            shift
            service "$@"
            ;;
        models)
            shift
            models "$@"
            ;;
        dashboard)
            shift
            dashboard "$@"
            ;;
        help)
            help_menu
            ;;
        bash-completion)
            install_completion
            ;;
        check-env)
            check_env
            ;;
        utils)
            shift
            utils_cmd "$@"
            ;;
        stack)
            shift
            stack_cmd "$@"
            ;;
        council)
            shift
            council_cmd "$@"
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            help_menu
            ;;
    esac
}

main "$@"