#!/usr/bin/env bash

set -e  # Exit on error
set -u  # Treat unset variables as an error
set -o pipefail  # Catch errors in pipelines

# Get script directory early (needed for compose file paths and library sourcing)
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# ‚îÄ‚îÄ Source shared libraries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Order matters: color.sh and common.sh first (no dependencies), then modules
# that depend on them. load_env_file must run before docker_utils.sh so that
# COMPOSE_FILE from .env is picked up during validation.
source "${SCRIPT_DIR}/lib/color.sh"
source "${SCRIPT_DIR}/lib/common.sh"

# Load environment variables from .env file (before docker_utils validates COMPOSE_FILE)
load_env_file ".env"

# docker_utils.sh validates COMPOSE_FILE and sets default COMPOSE_CMD/COMPOSE_WORKDIR
source "${SCRIPT_DIR}/lib/docker_utils.sh"
source "${SCRIPT_DIR}/lib/logging.sh"
source "${SCRIPT_DIR}/lib/env_check.sh"
source "${SCRIPT_DIR}/lib/pgadmin_utils.sh"
source "${SCRIPT_DIR}/lib/council_utils.sh"
source "${SCRIPT_DIR}/cli/lib/profile.sh"

# ‚îÄ‚îÄ AIXCL-specific constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CONTAINER_NAME="open-webui"

# Source the autocomplete script if it exists (with security validation)
COMPLETION_SCRIPT="${SCRIPT_DIR}/completion/aixcl.bash"
if [ -f "$COMPLETION_SCRIPT" ] && [[ "$COMPLETION_SCRIPT" =~ ^/ ]] && [ -r "$COMPLETION_SCRIPT" ]; then
    source "$COMPLETION_SCRIPT"
fi


# check_env() is provided by lib/env_check.sh

function ensure_databases() {
    # Ensure required databases exist (webui and continue)
    # This function is idempotent - it won't fail if databases already exist
    
    # Load environment variables if not already loaded
    if [ -z "${POSTGRES_USER:-}" ]; then
        if [ -f "${SCRIPT_DIR}/.env" ]; then
            load_env_file "${SCRIPT_DIR}/.env"
        fi
    fi
    
    # Set defaults
    local pg_user="${POSTGRES_USER:-admin}"
    local webui_db="${POSTGRES_DATABASE:-webui}"
    local continue_db="${POSTGRES_CONTINUE_DATABASE:-continue}"
    
    # Check if postgres container is running
    if ! docker ps --format "{{.Names}}" | grep -q "^postgres$"; then
        echo "‚ö†Ô∏è  PostgreSQL container is not running, skipping database creation"
        return 0
    fi
    
    # Wait for PostgreSQL to be ready
    local pg_ready=false
    for i in {1..10}; do
        if timeout 2 docker exec postgres pg_isready -U "$pg_user" >/dev/null 2>&1; then
            pg_ready=true
            break
        fi
        sleep 1
    done
    
    if [ "$pg_ready" = false ]; then
        echo "‚ö†Ô∏è  PostgreSQL is not ready, skipping database creation"
        return 0
    fi
    
    # Create webui database if it doesn't exist
    local webui_exists=$(docker exec postgres psql -U "$pg_user" -lqt 2>/dev/null | cut -d \| -f 1 | grep -w "$webui_db" | wc -l)
    webui_exists=${webui_exists:-0}
    if [ "$webui_exists" -eq 0 ]; then
        echo "Creating webui database: $webui_db"
        docker exec postgres psql -U "$pg_user" -d postgres -c "CREATE DATABASE \"$webui_db\";" >/dev/null 2>&1 || true
    else
        echo "WebUI database already exists: $webui_db"
    fi
    
    # Create continue database if it doesn't exist
    local continue_exists=$(docker exec postgres psql -U "$pg_user" -lqt 2>/dev/null | cut -d \| -f 1 | grep -w "$continue_db" | wc -l)
    continue_exists=${continue_exists:-0}
    if [ "$continue_exists" -eq 0 ]; then
        echo "Creating continue database: $continue_db"
        docker exec postgres psql -U "$pg_user" -d postgres -c "CREATE DATABASE \"$continue_db\";" >/dev/null 2>&1 || true
        echo "   Note: LLM-Council will automatically create the schema when it starts."
    else
        echo "Continue database already exists: $continue_db"
    fi
    
    # Remove unwanted "admin" database if it exists and is not the intended database
    # PostgreSQL may create an "admin" database when POSTGRES_USER=admin but POSTGRES_DATABASE is not set
    if [ "$webui_db" != "admin" ] && [ "$continue_db" != "admin" ]; then
        local admin_exists=$(docker exec postgres psql -U "$pg_user" -lqt 2>/dev/null | cut -d \| -f 1 | grep -w "admin" | wc -l)
        admin_exists=${admin_exists:-0}
        if [ "$admin_exists" -eq 1 ]; then
            echo "Removing unwanted admin database..."
            docker exec postgres psql -U "$pg_user" -d postgres -c "DROP DATABASE IF EXISTS \"admin\";" >/dev/null 2>&1 || true
            echo "   Admin database removed (only webui and continue databases should exist)"
        fi
    fi
}

# generate_pgadmin_config() is provided by lib/pgadmin_utils.sh

function start() {
    local profile=""
    local profile_specified=false
    
    # Profile library is sourced at script startup (cli/lib/profile.sh)
    
    # Parse arguments for profile
    local remaining_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile|-p)
                # Check if argument exists before accessing it
                if [[ $# -lt 2 ]] || [[ -z "${2:-}" ]]; then
                    echo "‚ùå Error: Profile name is required after --profile" >&2
                    echo "Usage: aixcl stack start [--profile <profile>]" >&2
                    echo "" >&2
                    list_profiles >&2
                    exit 1
                fi
                profile="$2"
                profile_specified=true
                shift 2
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # If no profile specified via command line, try to get from .env file
    if [ "$profile_specified" = false ]; then
        local env_file="${SCRIPT_DIR}/.env"
        
        # Load .env file to check for PROFILE variable
        if [ -f "$env_file" ]; then
            # Read PROFILE from .env file
            local env_profile=$(grep -E "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null | head -1 | cut -d '=' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//")
            
            if [ -n "$env_profile" ]; then
                profile="$env_profile"
                echo "‚ÑπÔ∏è  Using profile from .env file: $profile"
            fi
        fi
        
        # If still no profile, show available profiles and prompt
        if [ -z "$profile" ]; then
            # Ensure VALID_PROFILES is defined
            if [ -z "${VALID_PROFILES+x}" ] || [ ${#VALID_PROFILES[@]} -eq 0 ]; then
                echo "‚ùå Error: Profile definitions not loaded. VALID_PROFILES is not set." >&2
                echo "   Expected profile library at: ${SCRIPT_DIR}/cli/lib/profile.sh" >&2
                exit 1
            fi
            
            echo "Available profiles:"
            echo "==================="
            echo ""
            local profile_index=1
            for valid_profile in "${VALID_PROFILES[@]}"; do
                echo "  [$profile_index] $valid_profile: $(get_profile_description "$valid_profile")"
                ((profile_index++))
            done
            echo ""
            echo "Usage: ./aixcl stack start [--profile <profile>]"
            echo "       ./aixcl stack start -p <profile>"
            echo "       ./aixcl stack start                 # Uses PROFILE from .env file if set"
            echo ""
            echo "Note: Set PROFILE=<profile> in .env file to use a default profile"
            echo ""
            echo "Examples:"
            echo "  ./aixcl stack start --profile usr    # User-oriented runtime (minimal footprint with database persistence)"
            echo "  ./aixcl stack start --profile dev    # Developer workstation (UI + DB)"
            echo "  ./aixcl stack start --profile ops    # Observability-focused (monitoring/logging)"
            echo "  ./aixcl stack start --profile sys    # System-oriented (complete stack with automation)"
            echo ""
            echo "For detailed profile information, see: docs/architecture/governance/02_profiles.md"
            exit 0
        fi
    fi
    
    # Validate profile
    if ! is_valid_profile "$profile"; then
        echo "‚ùå Error: Invalid profile: $profile" >&2
        echo "Valid profiles: usr, dev, ops, sys"
        echo ""
        list_profiles
        exit 1
    fi
    
    # Save profile to .env file if it was specified via command line (and differs from .env)
    if [ "$profile_specified" = true ]; then
        local env_file="${SCRIPT_DIR}/.env"
        if [ -f "$env_file" ]; then
            local current_env_profile=$(grep -E "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null | head -1 | cut -d '=' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//")
            if [ "$current_env_profile" != "$profile" ]; then
                # Update or add PROFILE in .env file
                if grep -qE "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null; then
                    # Update existing PROFILE line
                    if [[ "$(uname)" == "Darwin" ]]; then
                        sed -i '' "s/^[[:space:]]*PROFILE[[:space:]]*=.*/PROFILE=$profile/" "$env_file"
                    else
                        sed -i "s/^[[:space:]]*PROFILE[[:space:]]*=.*/PROFILE=$profile/" "$env_file"
                    fi
                else
                    # Add PROFILE line at the end
                    echo "" >> "$env_file"
                    echo "# Default profile for stack commands" >> "$env_file"
                    echo "PROFILE=$profile" >> "$env_file"
                fi
                echo "‚ÑπÔ∏è  Saved profile to .env file: $profile"
            fi
        fi
    fi
    
    echo "Starting Docker Compose deployment with profile: $profile"
    print_profile_info "$profile"
    
    # Check for .env file and restore from backup or create from .env.example if missing
    # Use SCRIPT_DIR to ensure we're looking in the correct location
    local env_file="${SCRIPT_DIR}/.env"
    local env_example="${SCRIPT_DIR}/.env.example"
    local env_backup_volume="aixcl-env-backup"
    
    # NEVER overwrite existing .env file (preserves user configuration)
    if [ -f "$env_file" ]; then
        echo "‚úì Using existing .env file (preserving user configuration)"
        load_env_file "$env_file"
    else
        # Try to restore from backup volume first
        if docker volume ls --format "{{.Name}}" | grep -q "^${env_backup_volume}$"; then
            echo "‚ö†Ô∏è  .env file not found. Attempting to restore from backup..."
            # Restore .env from backup volume using a temporary container
            # Use current user's UID/GID to ensure proper ownership
            local current_uid=$(id -u)
            local current_gid=$(id -g)
            if docker run --rm \
                --user "${current_uid}:${current_gid}" \
                -v "${env_backup_volume}:/backup:ro" \
                -v "${SCRIPT_DIR}:/target" \
                alpine sh -c "test -f /backup/.env && cp /backup/.env /target/.env && chmod 600 /target/.env" >/dev/null 2>&1; then
                if [ -f "$env_file" ]; then
                    # Fix ownership and permissions if file was created by root
                    if [ -O "$env_file" ] || [ -w "$env_file" ]; then
                        chmod 600 "$env_file" 2>/dev/null || true
                        echo "‚úÖ Restored .env file from backup volume: $env_backup_volume"
                        load_env_file "$env_file"
                    else
                        # File exists but we don't have permission - try to fix ownership
                        echo "‚ö†Ô∏è  Restored .env file but fixing ownership..."
                        sudo chown "${current_uid}:${current_gid}" "$env_file" 2>/dev/null || {
                            echo "‚ùå Error: Cannot fix .env file ownership. Please run: sudo chown $(whoami):$(whoami) $env_file"
                            exit 1
                        }
                        chmod 600 "$env_file" 2>/dev/null || true
                        echo "‚úÖ Restored .env file from backup volume: $env_backup_volume"
                        load_env_file "$env_file"
                    fi
                else
                    echo "‚ö†Ô∏è  Backup exists but restoration failed, creating from .env.example..."
                fi
            else
                echo "‚ö†Ô∏è  Backup volume exists but .env not found in backup, creating from .env.example..."
            fi
        fi
        
        # If still no .env file, create from .env.example
        if [ ! -f "$env_file" ]; then
            if [ -f "$env_example" ]; then
                echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
                cp "$env_example" "$env_file"
                echo "‚úÖ Created .env file from .env.example"
                # Reload environment variables after creating .env file
                load_env_file "$env_file"
            else
                echo "‚ùå Error: Neither .env nor .env.example file found"
                echo "   Expected .env.example at: $env_example"
                echo "   Please create a .env file with the required configuration"
                exit 1
            fi
        fi
    fi
    
    # Get services for this profile
    local profile_services
    profile_services=($(get_profile_services "$profile"))
    
    # Generate pgAdmin configuration if pgadmin is in the profile
    local has_pgadmin=false
    for service in "${profile_services[@]}"; do
        if [ "$service" = "pgadmin" ]; then
            has_pgadmin=true
            break
        fi
    done
    
    if [ "$has_pgadmin" = true ]; then
        generate_pgadmin_config
    fi
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    # Check if any runtime core services are running
    local core_running=false
    for service in "${RUNTIME_CORE_SERVICES[@]}"; do
        if docker ps --format "{{.Names}}" | grep -q "^${service}$"; then
            core_running=true
            break
        fi
    done
    
    if [ "$core_running" = true ]; then
        echo "‚ö†Ô∏è  Some services are already running. Use 'stop' first if you want to restart."
        exit 1
    fi
    
    # Set profile-specific environment variables (per contract) BEFORE any docker-compose commands
    # All profiles use database storage (ENABLE_DB_STORAGE=true) for persistence
    # Export early to ensure it's available to all docker-compose commands (pull, build, up)
    export ENABLE_DB_STORAGE=$(get_profile_db_storage_enabled "$profile")
    echo "Setting ENABLE_DB_STORAGE=${ENABLE_DB_STORAGE} for profile: $profile"
    
    echo "Pulling latest images..."
    run_compose pull
    
    echo "Building LLM-Council service..."
    run_compose build llm-council
    
    if [ "$profile" = "usr" ]; then
        echo "Note: Usr profile includes PostgreSQL for database persistence (minimal footprint)"
    fi
    
    echo "Starting services for profile: $profile..."
    run_compose up -d "${profile_services[@]}"
    
    echo "Waiting for runtime core services to be ready..."
    local max_attempts=30
    local attempt=1
    local all_ready=false
    
    while [ $attempt -le $max_attempts ]; do
        local ollama_ready=false
        local council_ready=false
        
        # Check Ollama
        if curl -s -o /dev/null -w "%{http_code}" http://localhost:11434/api/version 2>/dev/null | grep -q "200"; then
            ollama_ready=true
        fi
        
        # Check LLM-Council
        if curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null | grep -q "200"; then
            council_ready=true
        fi
        
        if [ "$ollama_ready" = true ] && [ "$council_ready" = true ]; then
            all_ready=true
            break
        fi
        
        echo "Waiting for runtime core services to become available... ($attempt/$max_attempts)"
        sleep 2
        attempt=$((attempt + 1))
    done
    
    if [ "$all_ready" = true ]; then
        echo "Runtime core services are up and running!"
        
        # For profiles that include postgres, wait for it too
        local has_postgres=false
        for service in "${profile_services[@]}"; do
            if [ "$service" = "postgres" ]; then
                has_postgres=true
                break
            fi
        done
        
        if [ "$has_postgres" = true ]; then
            echo "Waiting for PostgreSQL to be ready..."
            local pg_attempt=1
            local pg_ready=false
            while [ $pg_attempt -le 15 ]; do
                if timeout 2 docker exec postgres pg_isready -U "${POSTGRES_USER:-admin}" >/dev/null 2>&1; then
                    echo "PostgreSQL is ready!"
                    pg_ready=true
                    break
                fi
                echo "Waiting for PostgreSQL... ($pg_attempt/15)"
                sleep 2
                pg_attempt=$((pg_attempt + 1))
            done
            
            # Ensure required databases exist
            if [ "$pg_ready" = true ]; then
                echo "Ensuring required databases exist..."
                ensure_databases
            fi
        fi
        
        status
        return 0
    else
        echo "‚ùå Error: Runtime core services did not start properly within timeout period"
        status
        exit 1
    fi
}

function stop() {
    echo "Stopping Docker Compose deployment..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
        echo "Services are not running."
        return 0
    fi
    
    echo "Stopping services gracefully..."
    run_compose down --remove-orphans
    
    echo "Waiting for containers to stop..."
    for i in {1..15}; do
        if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
            echo "All services stopped successfully."
            return 0
        fi
        echo "Waiting for services to stop... ($i/15)"
        sleep 2
    done
    
    echo "Warning: Services did not stop gracefully. Forcing shutdown..."
    run_compose down --remove-orphans -v
    docker ps -q | xargs -r docker stop
    
    echo "All services have been stopped."
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
}

function restart() {
    local profile=""
    local profile_specified=false
    
    # Profile library is sourced at script startup (cli/lib/profile.sh)
    
    # Parse arguments for profile and service names
    local remaining_args=()
    local service_names=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile|-p)
                if [[ $# -lt 2 ]] || [[ -z "${2:-}" ]]; then
                    echo "‚ùå Error: Profile name is required after --profile" >&2
                    echo "Usage: aixcl stack restart [--profile <profile>] [service1] [service2] ..." >&2
                    echo "" >&2
                    list_profiles >&2
                    exit 1
                fi
                profile="$2"
                profile_specified=true
                shift 2
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Check if remaining args are service names (not profile flags)
    # If they are valid service names, treat them as services to restart
    if [ ${#remaining_args[@]} -gt 0 ]; then
        # Source common library for service validation
        source "${SCRIPT_DIR}/lib/common.sh"
        
        # Check if any remaining args are valid service names
        for arg in "${remaining_args[@]}"; do
            if is_valid_service "$arg"; then
                service_names+=("$arg")
            else
                echo "‚ö†Ô∏è  Warning: '$arg' is not a valid service name, ignoring" >&2
            fi
        done
        
        # If we found valid service names, restart only those services
        if [ ${#service_names[@]} -gt 0 ]; then
            echo "Restarting specific services: ${service_names[*]}"
            for service in "${service_names[@]}"; do
                # Call the service function to restart each service
                service restart "$service" || {
                    echo "‚ùå Failed to restart service: $service" >&2
                    return 1
                }
            done
            echo "‚úÖ Successfully restarted ${#service_names[@]} service(s)"
            return 0
        fi
    fi
    
    # If no profile specified via command line, try to get from .env file
    if [ "$profile_specified" = false ]; then
        local env_file="${SCRIPT_DIR}/.env"
        
        # Load .env file to check for PROFILE variable
        if [ -f "$env_file" ]; then
            # Read PROFILE from .env file
            local env_profile=$(grep -E "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null | head -1 | cut -d '=' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//")
            
            if [ -n "$env_profile" ]; then
                profile="$env_profile"
                echo "‚ÑπÔ∏è  Using profile from .env file: $profile"
            fi
        fi
        
        # If still no profile, show error
        if [ -z "$profile" ]; then
            echo "‚ùå Error: Profile is required for restart command" >&2
            echo "" >&2
            echo "Available profiles:" >&2
            echo "===================" >&2
            echo "" >&2
            list_profiles >&2
            echo "" >&2
            echo "Usage: ./aixcl stack restart [--profile <profile>] [service1] [service2] ..." >&2
            echo "       ./aixcl stack restart -p <profile>" >&2
            echo "       ./aixcl stack restart ollama llm-council" >&2
            echo "" >&2
            echo "Note: You can set PROFILE=<profile> in .env file to use a default profile" >&2
            echo "" >&2
            echo "Examples:" >&2
            echo "  ./aixcl stack restart --profile sys          # Restart entire stack" >&2
            echo "  ./aixcl stack restart ollama llm-council     # Restart specific services" >&2
            echo "  ./aixcl stack restart -p dev                 # Restart entire stack with profile" >&2
            exit 1
        fi
    fi
    
    # Validate profile
    if ! is_valid_profile "$profile"; then
        echo "‚ùå Error: Invalid profile: $profile" >&2
        echo "Valid profiles: usr, dev, ops, sys" >&2
        echo ""
        list_profiles
        exit 1
    fi
    
    # Save profile to .env file if it was specified via command line (and differs from .env)
    if [ "$profile_specified" = true ]; then
        local env_file="${SCRIPT_DIR}/.env"
        if [ -f "$env_file" ]; then
            local current_env_profile=$(grep -E "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null | head -1 | cut -d '=' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//")
            if [ "$current_env_profile" != "$profile" ]; then
                # Update or add PROFILE in .env file
                if grep -qE "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null; then
                    # Update existing PROFILE line
                    if [[ "$(uname)" == "Darwin" ]]; then
                        sed -i '' "s/^[[:space:]]*PROFILE[[:space:]]*=.*/PROFILE=$profile/" "$env_file"
                    else
                        sed -i "s/^[[:space:]]*PROFILE[[:space:]]*=.*/PROFILE=$profile/" "$env_file"
                    fi
                else
                    # Add PROFILE line at the end
                    echo "" >> "$env_file"
                    echo "# Default profile for stack commands" >> "$env_file"
                    echo "PROFILE=$profile" >> "$env_file"
                fi
                echo "‚ÑπÔ∏è  Saved profile to .env file: $profile"
            fi
        fi
    fi
    
    echo "Restarting services with profile: $profile..."
    stop
    sleep 5
    start --profile "$profile"
}

function start_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service start <service-name>"
        echo ""
        echo "Runtime Core Services (always enabled):"
        echo "  ollama, llm-council"
        echo ""
        echo "Operational Services (profile-dependent):"
        echo "  ${ALL_SERVICES[*]}"
        echo ""
        echo "Note: Continue is a VS Code plugin, not a containerized service"
        echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
        return 1
    fi
    
    local service="$1"
    local force_recreate="${2:-false}"  # Optional second parameter to force recreate
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo ""
        echo "Runtime Core Services (always enabled): ollama, llm-council"
        echo "Operational Services (profile-dependent): ${ALL_SERVICES[*]}"
        echo ""
        echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    # Check if service is already running (handle both exact name and hash-prefixed names)
    if docker ps --format "{{.Names}}" | grep -qE "^${container_name}$|_[0-9a-f]+_${container_name}$|^[0-9a-f]+_${container_name}$"; then
        echo "Service '$service' is already running."
        return 0
    fi
    
    # Remove any existing containers (running or stopped) to avoid ContainerConfig errors
    # This is especially important after rebuilds when docker-compose tries to recreate containers
    echo "Cleaning up any existing containers for $service..."
    run_compose rm -f "$service" 2>/dev/null || true
    
    # Also remove hash-prefixed containers directly via docker (handles edge cases)
    local hash_prefixed=$(docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "_${container_name}$|^[0-9a-f]+_${container_name}$" | awk '{print $1}')
    if [ -n "$hash_prefixed" ]; then
        echo "Removing hash-prefixed containers to avoid docker-compose issues..."
        echo "$hash_prefixed" | while read -r container_id; do
            docker rm -f "$container_id" 2>/dev/null || true
        done
    fi
    
    # Remove container by exact name if it exists
    docker rm -f "$container_name" 2>/dev/null || true
    
    echo "Starting service: $service..."
    
    # Check for .env file if needed (for services that require it)
    if [ ! -f .env ] && [ "$service" = "open-webui" ] || [ "$service" = "postgres" ] || [ "$service" = "pgadmin" ]; then
        if [ -f .env.example ]; then
            echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
            cp .env.example .env
            load_env_file ".env"
        else
            echo "‚ùå Error: .env file required for service '$service'"
            return 1
        fi
    fi
    
    # Generate pgAdmin configuration if starting pgadmin
    if [ "$service" = "pgadmin" ]; then
        generate_pgadmin_config
    fi
    
    # Start the specific service
    # Use --force-recreate if explicitly requested (e.g., after a rebuild)
    if [ "$force_recreate" = "true" ]; then
        if run_compose up -d --force-recreate --no-deps "$service"; then
            echo "‚úÖ Successfully started service: $service (recreated)"
        else
            echo "‚ùå Failed to start service: $service"
            return 1
        fi
    else
        if run_compose up -d "$service"; then
            echo "‚úÖ Successfully started service: $service"
        else
            echo "‚ùå Failed to start service: $service"
            return 1
        fi
    fi
    
    # Wait a moment for the service to initialize
    sleep 2
    
    # Check if the container is actually running (handle both exact name and hash-prefixed names)
    if docker ps --format "{{.Names}}" | grep -qE "^${container_name}$|_[0-9a-f]+_${container_name}$|^[0-9a-f]+_${container_name}$"; then
        echo "Service '$service' is now running."
    else
        echo "‚ö†Ô∏è  Service '$service' may not have started correctly. Check logs with: $0 logs $service"
    fi
    return 0
}

function stop_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service stop <service-name>"
        echo ""
        echo "Runtime Core Services (always enabled): ollama, llm-council"
        echo "Operational Services (profile-dependent): ${ALL_SERVICES[*]}"
        echo ""
        echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
        return 1
    fi
    
    local service="$1"
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo ""
        echo "Runtime Core Services (always enabled): ollama, llm-council"
        echo "Operational Services (profile-dependent): ${ALL_SERVICES[*]}"
        echo ""
        echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Check if service is running
    if ! docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Service '$service' is not running."
        return 0
    fi
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping service: $service..."
    
    # Stop the specific service
    if run_compose stop "$service"; then
        echo "‚úÖ Successfully stopped service: $service"
        
        # Clean up pgAdmin configuration if stopping pgadmin
        if [ "$service" = "pgadmin" ] && [ -f "pgadmin-servers.json" ]; then
            rm -f pgadmin-servers.json
            echo "üßπ Cleaned up pgAdmin configuration file"
        fi
        return 0
    else
        echo "‚ùå Failed to stop service: $service"
        return 1
    fi
}

function needs_rebuild() {
    local service="$1"
    
    # Services that require builds (have build context in docker-compose.yml)
    case "$service" in
        "llm-council")
            local build_context="${SCRIPT_DIR}/llm-council"
            local dockerfile="${build_context}/Dockerfile"
            
            if [ ! -d "$build_context" ] || [ ! -f "$dockerfile" ]; then
                return 1  # Can't determine, assume no rebuild needed
            fi
            
            # Check if image exists
            if ! docker images --format "{{.Repository}}:{{.Tag}}" 2>/dev/null | grep -q "^llm-council:latest$"; then
                return 0  # Image doesn't exist, needs build
            fi
            
            # Get image creation timestamp (Unix epoch)
            local image_timestamp=$(docker inspect --format='{{.Created}}' llm-council:latest 2>/dev/null)
            if [ -z "$image_timestamp" ]; then
                return 0  # Can't inspect image, rebuild to be safe
            fi
            
            # Convert image creation time to Unix timestamp
            local image_epoch=$(date -d "$image_timestamp" +%s 2>/dev/null || echo "0")
            if [ "$image_epoch" -eq 0 ]; then
                # Try alternative date parsing (for different date formats)
                image_epoch=$(date -d "$(echo "$image_timestamp" | sed 's/T/ /' | cut -d. -f1)" +%s 2>/dev/null || echo "0")
            fi
            
            # Check if any critical source files are newer than the image
            # Check Python files in backend directory (most likely to change)
            local backend_dir="${build_context}/backend"
            if [ -d "$backend_dir" ]; then
                # Find the most recently modified Python file
                local latest_py=$(find "$backend_dir" -type f -name "*.py" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
                if [ -n "$latest_py" ] && [ -f "$latest_py" ]; then
                    local file_epoch=$(stat -c %Y "$latest_py" 2>/dev/null || echo "0")
                    if [ "$file_epoch" -gt "$image_epoch" ]; then
                        return 0  # Source file is newer than image, needs rebuild
                    fi
                fi
            fi
            
            # Check Dockerfile
            if [ -f "$dockerfile" ]; then
                local dockerfile_epoch=$(stat -c %Y "$dockerfile" 2>/dev/null || echo "0")
                if [ "$dockerfile_epoch" -gt "$image_epoch" ]; then
                    return 0  # Dockerfile is newer than image, needs rebuild
                fi
            fi
            
            # Check pyproject.toml
            local pyproject="${build_context}/pyproject.toml"
            if [ -f "$pyproject" ]; then
                local pyproject_epoch=$(stat -c %Y "$pyproject" 2>/dev/null || echo "0")
                if [ "$pyproject_epoch" -gt "$image_epoch" ]; then
                    return 0  # pyproject.toml is newer than image, needs rebuild
                fi
            fi
            
            return 1  # No rebuild needed
            ;;
        *)
            # Other services don't require builds (use pre-built images)
            return 1
            ;;
    esac
}

function service() {
    if [[ $# -lt 2 ]]; then
        echo "Error: Service action and name are required"
        echo "Usage: $0 service {start|stop|restart} <service-name>"
        echo ""
        echo "Runtime Core Services (always enabled): ollama, llm-council"
        echo "Operational Services (profile-dependent): ${ALL_SERVICES[*]}"
        echo ""
        echo "Note: Continue is a VS Code plugin, not a containerized service"
        echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
        return 1
    fi
    
    local action="$1"
    local service="$2"
    shift 2
    
    # Check for extra arguments
    if [ $# -gt 0 ]; then
        echo "Error: Unknown argument '$1'"
        echo "Usage: $0 service {start|stop|restart} <service-name>"
        return 1
    fi
    
    case "$action" in
        start)
            start_service "$service"
            ;;
        stop)
            stop_service "$service"
            ;;
        restart)
            echo "Restarting service: $service..."
            
            # Set up compose command early
            set_compose_cmd
            
            # Check if service needs rebuild
            if needs_rebuild "$service"; then
                echo "üî® Source code changes detected. Rebuilding $service..."
                
                # Stop and remove the service completely to avoid ContainerConfig errors
                stop_service "$service" 2>/dev/null || true
                
                # Force remove any existing containers (including hash-prefixed ones)
                echo "Removing existing containers for clean rebuild..."
                run_compose rm -f "$service" 2>/dev/null || true
                local container_name=$(get_container_name "$service")
                docker rm -f "$container_name" 2>/dev/null || true
                # Remove any hash-prefixed containers
                docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "_${container_name}$|^[0-9a-f]+_${container_name}$" | awk '{print $1}' | xargs -r docker rm -f 2>/dev/null || true
                
                # Rebuild the service
                echo "Building $service..."
                if run_compose build "$service"; then
                    echo "‚úÖ Successfully rebuilt $service"
                else
                    echo "‚ùå Failed to rebuild $service"
                    return 1
                fi
                
                # Start with force recreate after rebuild
                start_service "$service" "true"
            else
                # Just stop without rebuild
                stop_service "$service"
                sleep 2
                start_service "$service"
            fi
            ;;
        *)
            echo "Error: Unknown service action '$action'"
            echo "Available actions: start, stop, restart"
            return 1
            ;;
    esac
}

function logs() {
    if [ $# -eq 0 ]; then
        echo "Fetching logs for all services (following)..."
        echo "Press Ctrl+C to stop"
        echo ""
        
        # Check if any containers are running
        local services=("ollama" "open-webui" "postgres" "pgadmin" "llm-council" "watchtower" "prometheus" "grafana" "cadvisor" "node-exporter" "postgres-exporter" "nvidia-gpu-exporter" "loki" "promtail")
        local found_any=false
        local running_containers=()
        
        for service in "${services[@]}"; do
            # Check for exact match or hash-prefixed match
            if docker ps --format "{{.Names}}" 2>/dev/null | grep -qE "^${service}$|_[0-9a-f]+_${service}$|^[0-9a-f]+_${service}$"; then
                found_any=true
                running_containers+=("$service")
            fi
        done
        
        if [ "$found_any" = false ]; then
            echo "‚ö†Ô∏è  No services are currently running."
            echo "   Start services with: ./aixcl stack start"
            return 0
        fi
        
        # Use docker logs directly for each running container
        # Show last 100 lines then follow for each container
        for service in "${running_containers[@]}"; do
            echo "=== $service ==="
            docker logs "$service" --tail=100 2>/dev/null || echo "  (no logs available)"
            echo ""
        done
        
        echo "Following new logs (Press Ctrl+C to stop)..."
        echo ""
        
        # Follow logs from all containers in parallel using background processes
        local pids=()
        for service in "${running_containers[@]}"; do
            (
                docker logs "$service" --follow 2>/dev/null | while IFS= read -r line; do
                    echo "[$service] $line"
                done
            ) &
            pids+=($!)
        done
        
        # Wait for all background processes
        wait "${pids[@]}"
    else
        local container="$1"
        local tail_count="${2:-50}"  # Default to 50 lines if not specified
        
        # Validate tail_count
        if [[ ! "$tail_count" =~ ^[0-9]+$ ]] || [[ "$tail_count" -lt 1 ]] || [[ "$tail_count" -gt 10000 ]]; then
            echo "‚ùå tail count must be a number between 1 and 10000"
            return 1
        fi
        
        # Validate container name and find actual container (handle hash-prefixed names)
        case "$container" in
            ollama|open-webui|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter|loki|promtail)
                echo "Fetching logs for $container..."
                # Try exact name first, then hash-prefixed name
                local actual_container
                actual_container=$(docker ps --format "{{.Names}}" 2>/dev/null | grep -E "^${container}$|_[0-9a-f]+_${container}$|^[0-9a-f]+_${container}$" | head -1)
                if [ -n "$actual_container" ]; then
                    docker logs "$actual_container" --tail="$tail_count" --follow
                else
                    # Try stopped containers too
                    actual_container=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "^${container}$|_[0-9a-f]+_${container}$|^[0-9a-f]+_${container}$" | head -1)
                    if [ -n "$actual_container" ]; then
                        docker logs "$actual_container" --tail="$tail_count" --follow
                    else
                        echo "Error: Container '$container' not found (checked for exact name and hash-prefixed variants)"
                        return 1
                    fi
                fi
                ;;
            *)
                echo "Error: Unknown container '$container'"
                echo ""
                echo "Runtime Core Services: ollama, llm-council"
                echo "Operational Services: open-webui, postgres, pgadmin, watchtower, prometheus, grafana, cadvisor, node-exporter, postgres-exporter, nvidia-gpu-exporter, loki, promtail"
                echo ""
                echo "For service contracts and profiles, see: docs/architecture/governance/service_contracts/"
                return 1
                ;;
        esac
    fi
}

function clean() {
    echo "Cleaning up Docker resources..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping all containers..."
    run_compose down
    
    # Remove postgres container and associated volumes specifically
    if docker ps -a --format "{{.Names}}" | grep -q "^postgres$"; then
        echo "Removing PostgreSQL container..."
        docker rm -f postgres 2>/dev/null || true
    fi
    
    # Remove postgres-related volumes
    echo "Removing PostgreSQL volumes..."
    docker volume ls --format "{{.Name}}" | grep -i postgres | while read -r volume; do
        if [ -n "$volume" ]; then
            echo "  Removing volume: $volume"
            docker volume rm "$volume" 2>/dev/null || true
        fi
    done
    
    echo "Removing stopped containers..."
    docker container prune -f
    
    echo "Removing unused images..."
    docker image prune -a -f
    
    echo "Removing unused volumes..."
    docker volume prune -f
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
    
    echo "Clean up complete."
}

function status() {
    # Profile library is sourced at script startup (cli/lib/profile.sh)
    
    # Get current profile from .env file
    local current_profile=""
    local env_file="${SCRIPT_DIR}/.env"
    if [ -f "$env_file" ]; then
        current_profile=$(grep -E "^[[:space:]]*PROFILE[[:space:]]*=" "$env_file" 2>/dev/null | head -1 | cut -d '=' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//")
    fi
    
    # Determine overall status (Running/Stopped)
    local overall_status="Stopped"
    if docker ps --format "{{.Names}}" | grep -qE "ollama|llm-council|postgres|open-webui|pgadmin|prometheus|grafana|loki|promtail|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter|watchtower"; then
        overall_status="Running"
    fi
    
    # Health counters (not local so nested function can modify them)
    runtime_core_total=0
    runtime_core_healthy=0
    operational_total=0
    operational_healthy=0
    
    # Helper function to check both container status and health
    # Returns: 0=healthy, 1=unhealthy, 2=stopped
    # health_check_type can be: "curl" (with URL), "pg_isready" (with username), "status_var" (with variable name), or empty (no health check)
    check_service_status() {
        local service_name="$1"
        local container_name="$2"
        local health_check_type="$3"
        local health_check_arg="$4"
        local is_critical="${5:-false}"
        local is_runtime_core="${6:-false}"
        
        # Check container status
        local container_running=false
        if docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
            container_running=true
            local container_status="‚úÖ"
        else
            container_status="‚ùå"
        fi
        
        # Check health (only if container is running)
        local health_status=""
        local is_healthy=false
        if [ "$container_running" = "true" ] && [ -n "$health_check_type" ]; then
            local health_result=""
            
            case "$health_check_type" in
                curl)
                    # Safe curl-based health check - URL is passed as argument and quoted
                    if [ -n "$health_check_arg" ]; then
                        # Try health endpoint first with a short timeout
                        health_result=$(curl -s -o /dev/null -w "%{http_code}" --max-time 3 "$health_check_arg" 2>/dev/null || echo "000")
                        # If health endpoint returns 404 or 000, try root endpoint as fallback (for services like Open WebUI)
                        if [ "$health_result" = "404" ] || [ "$health_result" = "000" ]; then
                            # Extract base URL by removing /health or any trailing path
                            local base_url="${health_check_arg%/health}"
                            base_url="${base_url%/}"
                            # Try root endpoint with fallback
                            local root_result=$(curl -s -o /dev/null -w "%{http_code}" --max-time 3 "$base_url/" 2>/dev/null || echo "000")
                            if [ "$root_result" = "200" ] || [ "$root_result" = "302" ] || [ "$root_result" = "307" ]; then
                                health_result="$root_result"
                            fi
                        fi
                    fi
                    ;;
                pg_isready)
                    # Safe PostgreSQL health check - username is validated and quoted
                    # health_check_arg should be the PostgreSQL username
                    if [ -n "$health_check_arg" ] && [ -n "$container_name" ]; then
                        # Validate username contains only safe characters (already done at call site, but double-check)
                        local pg_user="$health_check_arg"
                        if [[ "$pg_user" =~ ^[A-Za-z0-9_-]+$ ]]; then
                            # Execute docker exec with properly quoted arguments
                            if timeout 2 docker exec "$container_name" pg_isready -U "$pg_user" >/dev/null 2>&1; then
                                health_result="healthy"
                            else
                                health_result="unhealthy"
                            fi
                        else
                            health_result="unhealthy"
                        fi
                    fi
                    ;;
                status_var)
                    # Safe variable-based health check (already computed)
                    if [ -n "$health_check_arg" ]; then
                        # Use indirect variable reference safely
                        local var_name="$health_check_arg"
                        health_result="${!var_name:-000}"
                    fi
                    ;;
                *)
                    # Unknown type, skip health check
                    ;;
            esac
            
            if [ "$health_result" = "200" ] || [ "$health_result" = "302" ] || [ "$health_result" = "307" ] || [ "$health_result" = "healthy" ]; then
                health_status=""
                is_healthy=true
            else
                health_status=""
                if [ "$is_critical" = "true" ]; then
                    echo "    Checking ${service_name} logs (last 3 lines):"
                    timeout 2 docker logs "${container_name}" --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
                fi
            fi
        elif [ "$container_running" = "false" ]; then
            health_status=""
        fi
        
        # Update counters (use || true to prevent set -e from exiting on arithmetic)
        if [ "$is_runtime_core" = "true" ]; then
            ((runtime_core_total++)) || true
            if [ "$is_healthy" = "true" ]; then
                ((runtime_core_healthy++)) || true
            fi
        else
            ((operational_total++)) || true
            if [ "$is_healthy" = "true" ]; then
                ((operational_healthy++)) || true
            fi
        fi
        
        echo "  ${container_status} ${service_name}${health_status}"
    }
    
    # Header section
    echo "AIXCL Stack Status"
    echo "=================="
    echo ""
    
    if [ -n "$current_profile" ] && is_valid_profile "$current_profile" 2>/dev/null; then
        echo "Profile: $current_profile"
    else
        echo "Profile: (not set)"
    fi
    echo "Status: $overall_status"
    echo ""
    
    # Runtime Core (Strict - Always Enabled) per governance model
    echo "Runtime Core (Strict - Always Enabled)"
    echo "---------------------------------------"
    check_service_status "Ollama" "ollama" "curl" "http://localhost:11434/api/version" "true" "true"
    check_service_status "LLM-Council" "llm-council" "curl" "http://localhost:8000/health" "true" "true"
    
    # Continue is a VS Code plugin, not a containerized service
    # Check if LLM-Council API is accessible (which Continue connects to)
    local continue_status="‚ùå"
    local continue_state="Inactive"
    local continue_note="(VS Code plugin - LLM-Council unavailable)"
    local continue_healthy=false
    if curl -s -o /dev/null -w "%{http_code}" --max-time 3 "http://localhost:8000/health" 2>/dev/null | grep -q "200"; then
        continue_status="‚úÖ"
        continue_state="Active"
        continue_note="Connected (VS Code plugin)"
        continue_healthy=true
        ((runtime_core_total++)) || true
        ((runtime_core_healthy++)) || true
    else
        continue_state="Inactive"
        ((runtime_core_total++)) || true
    fi
    echo "  ${continue_status} continue        ${continue_state}     ${continue_note}"
    echo ""
    
    # Operational Services (Guided - Profile-Dependent) per governance model
    echo "Operational Services (Guided - Profile-Dependent)"
    echo "--------------------------------------------------"
    
    # UI Services
    check_service_status "Open WebUI" "$CONTAINER_NAME" "curl" "http://localhost:8080/health" "false" "false"
    
    # Persistence Services
    # Security fix: Properly validate and quote POSTGRES_USER to prevent injection
    # Validate POSTGRES_USER contains only safe characters before use
    local postgres_user="${POSTGRES_USER:-webui}"
    # Sanitize: only allow alphanumeric, underscore, and hyphen
    if [[ ! "$postgres_user" =~ ^[A-Za-z0-9_-]+$ ]]; then
        postgres_user="webui"
        echo "‚ö†Ô∏è  Warning: Invalid POSTGRES_USER value, using default 'webui'" >&2
    fi
    check_service_status "PostgreSQL" "postgres" "pg_isready" "$postgres_user" "false" "false"
    
    PGADMIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null || echo "000")
    check_service_status "pgAdmin" "pgadmin" "status_var" "PGADMIN_STATUS" "false" "false"

    # Observability Services
    PROMETHEUS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9090/-/healthy 2>/dev/null || echo "000")
    check_service_status "Prometheus" "prometheus" "status_var" "PROMETHEUS_STATUS" "false" "false"

    GRAFANA_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null || echo "000")
    check_service_status "Grafana" "grafana" "status_var" "GRAFANA_STATUS" "false" "false"

    CADVISOR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/metrics 2>/dev/null || echo "000")
    check_service_status "cAdvisor" "cadvisor" "status_var" "CADVISOR_STATUS" "false" "false"

    NODE_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9100/metrics 2>/dev/null || echo "000")
    check_service_status "Node Exporter" "node-exporter" "status_var" "NODE_EXPORTER_STATUS" "false" "false"

    POSTGRES_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9187/metrics 2>/dev/null || echo "000")
    check_service_status "Postgres Exporter" "postgres-exporter" "status_var" "POSTGRES_EXPORTER_STATUS" "false" "false"

    if docker ps --format "{{.Names}}" | grep -q "^nvidia-gpu-exporter$"; then
        NVIDIA_GPU_EXPORTER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9400/metrics 2>/dev/null || echo "000")
        check_service_status "NVIDIA GPU Exporter" "nvidia-gpu-exporter" "status_var" "NVIDIA_GPU_EXPORTER_STATUS" "false" "false"
    else
        echo "  ‚ö†Ô∏è  NVIDIA GPU Exporter (expected on non-GPU systems)"
        # Don't count NVIDIA GPU Exporter in totals if it's not expected
    fi

    # (Loki and Promtail are part of Observability)
    if docker ps --format "{{.Names}}" | grep -q "^loki$"; then
        LOKI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3100/ready 2>/dev/null || echo "000")
        if [ "$LOKI_STATUS" = "200" ]; then
            echo "  ‚úÖ Loki"
            ((operational_total++)) || true
            ((operational_healthy++)) || true
        elif [ "$LOKI_STATUS" = "503" ]; then
            echo "  ‚ö†Ô∏è  Loki (starting up)"
            ((operational_total++)) || true
        else
            echo "  ‚ùå Loki"
            echo "    Checking Loki logs (last 3 lines):"
            timeout 2 docker logs loki --tail 3 2>/dev/null || echo "    (Logs unavailable or timeout)"
            ((operational_total++)) || true
        fi
    else
        echo "  ‚ùå Loki"
        ((operational_total++)) || true
    fi

    if docker ps --format "{{.Names}}" | grep -q "^promtail$"; then
        if docker exec promtail wget --no-verbose --tries=1 --spider http://localhost:9080/ready 2>/dev/null; then
            echo "  ‚úÖ Promtail"
            ((operational_total++)) || true
            ((operational_healthy++)) || true
        else
            echo "  ‚ùå Promtail"
            ((operational_total++)) || true
        fi
    else
        echo "  ‚ùå Promtail"
        ((operational_total++)) || true
    fi

    # Automation Services
    if docker ps --format "{{.Names}}" | grep -q "^watchtower$"; then
        echo "  ‚úÖ Watchtower"
        ((operational_total++)) || true
        ((operational_healthy++)) || true
    else
        echo "  ‚ùå Watchtower"
        ((operational_total++)) || true
    fi
    
    # Health Summary section
    echo ""
    echo "Health Summary"
    echo "--------------"
    
    # Runtime Core summary
    if [ $runtime_core_total -gt 0 ]; then
        echo "Runtime Core: $runtime_core_healthy/$runtime_core_total healthy"
    else
        echo "Runtime Core: 0/0 healthy"
    fi
    
    # Operational summary
    if [ $operational_total -gt 0 ]; then
        echo "Operational:  $operational_healthy/$operational_total healthy"
    else
        echo "Operational:  0/0 (no operational services enabled)"
    fi
    
    # Overall status
    if [ $runtime_core_healthy -eq $runtime_core_total ] && [ $runtime_core_total -gt 0 ]; then
        echo "Overall:      ‚úÖ All critical services healthy"
    elif [ $runtime_core_total -eq 0 ]; then
        echo "Overall:      ‚ö†Ô∏è  No services running"
    else
        echo "Overall:      ‚ùå Critical services unhealthy"
    fi
    echo ""
}

function add() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models add <model-name> [<model-name> ...]"
        echo "Example: $0 models add starcoder2:latest"
        echo "Example: $0 models add starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Adding model: $1"
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec "$ollama_container" ollama pull "$1"; then
        echo "‚úÖ Successfully added model: $1"
    else
        echo "‚ùå Failed to add model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function remove() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models remove <model-name> [<model-name> ...]"
        echo "Example: $0 models remove starcoder2:latest"
        echo "Example: $0 models remove starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Removing model: $1"
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec "$ollama_container" ollama rm "$1"; then
        echo "‚úÖ Successfully removed model: $1"
    else
        echo "‚ùå Failed to remove model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function models() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Models action is required"
        echo "Usage: $0 models {add|remove|list} [<model-name> ...]"
        echo "Examples:"
        echo "  $0 models add starcoder2:latest"
        echo "  $0 models remove starcoder2:latest nomic-embed-text:latest"
        echo "  $0 models list"
        return 1
    fi

    local action="$1"
    shift

    local status=0

    case "$action" in
        add)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for add"
                echo "Usage: $0 models add <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! add "$model"; then
                    status=1
                fi
            done
            ;;
        remove)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for remove"
                echo "Usage: $0 models remove <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! remove "$model"; then
                    status=1
                fi
            done
            ;;
        list)
            if [[ $# -gt 0 ]]; then
                echo "Error: Unknown argument '$1'"
                echo "Usage: $0 models {add|remove|list} [<model-name> ...]"
                return 1
            fi
            list
            ;;
        *)
            echo "Error: Unknown models action '$action'"
            echo "Usage: $0 models {add|remove|list} [<model-name> ...]"
            return 1
            ;;
    esac

    return $status
}

function list() {
    echo "Listing installed models..."
    
    local ollama_container
    ollama_container=$(get_ollama_container)
    
    if [ -z "$ollama_container" ]; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    docker exec "$ollama_container" ollama list
}

function open_url_in_browser() {
    local url="$1"

    if command -v xdg-open &> /dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open &> /dev/null; then
        open "$url" 2>/dev/null &
    else
        echo "‚ö†Ô∏è  Could not detect default browser. Please open $url manually."
    fi
}

function dashboard_grafana() {
    echo "Opening Grafana monitoring dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "grafana"; then
        echo "‚ùå Grafana container is not running. Please start the services first."
        return 1
    fi

    # Check if Grafana is responding
    if ! curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null | grep -q "200"; then
        echo "‚ùå Grafana is not responding yet. Please wait for it to start."
        return 1
    fi

    local url="http://localhost:3000"
    echo "Grafana is available at: $url"
    echo "Default credentials: admin / admin (change on first login)"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_openwebui() {
    echo "Opening Open WebUI dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "‚ùå Open WebUI container is not running. Please start the services first."
        return 1
    fi

    local health_status
    health_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null || echo "000")

    if [ "$health_status" != "200" ]; then
        echo "‚ùå Open WebUI is not responding yet (HTTP $health_status). Please wait for it to start."
        return 1
    fi

    local url="http://localhost:8080"
    echo "Open WebUI is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_pgadmin() {
    echo "Opening pgAdmin dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "pgadmin"; then
        echo "‚ùå pgAdmin container is not running. Please start the services first."
        return 1
    fi

    local pgadmin_status
    pgadmin_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null || echo "000")

    case "$pgadmin_status" in
        200|302)
            ;;
        *)
            echo "‚ùå pgAdmin is not responding yet (HTTP $pgadmin_status). Please wait for it to start."
            return 1
            ;;
    esac

    local url="http://localhost:5050"
    echo "pgAdmin is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Missing dashboard target."
        echo "Usage: $0 dashboard {openwebui|grafana|pgadmin}"
        return 1
    fi

    local target="$1"
    shift

    # Check for extra arguments
    if [ $# -gt 0 ]; then
        echo "Error: Unknown argument '$1'"
        echo "Usage: $0 dashboard {openwebui|grafana|pgadmin}"
        return 1
    fi

    case "$target" in
        grafana)
            dashboard_grafana
            ;;
        openwebui|open-webui|open_webui)
            dashboard_openwebui
            ;;
        pgadmin)
            dashboard_pgadmin
            ;;
        *)
            echo "Error: Unknown dashboard target '$target'"
            echo "Usage: $0 dashboard {openwebui|grafana|pgadmin}"
            return 1
            ;;
    esac
}

function help_menu() {
    echo "Usage: ./aixcl <cmd> [options]"
    echo ""
    echo "Stack: stack <action> [options]"
    echo "  stack start [--profile <profile>]    - Start services (uses PROFILE from .env if set)"
    echo "  stack start -p <profile>            - Short form: Start with profile"
    echo "  stack start                         - Start with profile from .env (or show profiles)"
    echo "  stack stop                          - Stop all services"
    echo "  stack restart [--profile <profile>] - Restart services (uses .env PROFILE if not specified)"
    echo "  stack status                        - Show service status"
    echo "  stack logs [service] [lines]        - Show logs"
    echo "  stack clean                         - Clean Docker resources"
    echo ""
    echo "  Profiles (usr, dev, ops, sys):"
    echo "    usr   - User-oriented runtime (Ollama, LLM-Council, PostgreSQL for persistence)"
    echo "    dev   - Developer workstation (runtime core + UI + DB)"
    echo "    ops   - Observability-focused (runtime core + monitoring/logging)"
    echo "    sys   - System-oriented (complete stack with automation)"
    echo ""
    echo "Service: service <action> <name>"
    echo "  Runtime Core (always enabled): ollama, llm-council"
    echo "  Operational Services (profile-dependent): see docs/architecture/governance/02_profiles.md"
    echo ""
    echo "Models: models <action> [name]"
    echo "  models add <name>                   - Add model(s) to Ollama"
    echo "  models remove <name>                - Remove model(s) from Ollama"
    echo "  models list                         - List installed models"
    echo ""
    echo "Council: council <action>"
    echo "  council configure                   - Configure council models and chairman"
    echo "  council status                      - Show council configuration and status"
    echo ""
    echo "Query: query [options] <question>"
    echo "  query '<question>'                  - One-shot query via Goose (clean output)"
    echo "  query session                       - Start interactive Goose session"
    echo ""
    echo "Dashboard: dashboard <name>"
    echo "  dashboard openwebui                 - Open Open WebUI"
    echo "  dashboard grafana                   - Open Grafana monitoring"
    echo "  dashboard pgadmin                   - Open pgAdmin database admin"
    echo ""
    echo "Utils: utils <action>"
    echo "  utils check-env                     - Verify environment setup"
    echo "  utils bash-completion               - Install bash completion"
    echo ""
    echo "For detailed profile definitions, see: docs/architecture/governance/02_profiles.md"
    exit 1
}

function install_completion() {
    echo "Installing bash completion for aixcl..."
    echo "Cleaning up any existing completion files..."
    
    # Get the script directory (already set globally)
    # SCRIPT_DIR and COMPLETION_SCRIPT are already defined at script startup
    
    if [[ ! -f "$COMPLETION_SCRIPT" ]]; then
        echo "Error: Completion script not found at $COMPLETION_SCRIPT"
        exit 1
    fi
    
    # Clean up existing completion files
    local cleanup_dirs=(
        "$HOME/.local/share/bash-completion/completions"
        "/etc/bash_completion.d"
    )
    
    for dir in "${cleanup_dirs[@]}"; do
        if [[ -f "$dir/aixcl" ]]; then
            echo "Removing existing completion file: $dir/aixcl"
            rm -f "$dir/aixcl"
        fi
    done
    
    # Clean up .bashrc - remove any old aixcl completion references
    if [[ -f "$HOME/.bashrc" ]]; then
        echo "Cleaning up .bashrc..."
        local temp_bashrc="$(mktemp)"
        # Remove the entire completion block using sed
        # Pattern: from "Added by aixcl installer" through the next standalone "fi"
        sed '/Added by aixcl installer/,/^[[:space:]]*fi[[:space:]]*$/d' "$HOME/.bashrc" > "$temp_bashrc" || cp "$HOME/.bashrc" "$temp_bashrc"
        
        # Also remove any broken if/fi pairs where if contains aixcl but source was already removed
        # This handles the case where only "if ... then" and "fi" remain
        awk '
            BEGIN { prev_line = ""; prev_prev_line = "" }
            {
                # Check if current line is "fi" and previous was an empty if statement for aixcl
                if (/^[[:space:]]*fi[[:space:]]*$/) {
                    if (prev_line ~ /^[[:space:]]*if[[:space:]]+\[.*aixcl.*\][[:space:]]*;[[:space:]]*then[[:space:]]*$/) {
                        # This is an empty if/fi block for aixcl, skip both
                        prev_line = ""
                        prev_prev_line = ""
                        next
                    } else {
                        # Normal fi, keep it
                        if (prev_prev_line != "") print prev_prev_line
                        if (prev_line != "") print prev_line
                        print $0
                        prev_prev_line = ""
                        prev_line = ""
                        next
                    }
                }
                # Not a fi, so print previous lines if we have them
                if (prev_prev_line != "") {
                    print prev_prev_line
                    prev_prev_line = ""
                }
                if (prev_line != "") {
                    prev_prev_line = prev_line
                }
                prev_line = $0
            }
            END {
                if (prev_prev_line != "") print prev_prev_line
                if (prev_line != "") print prev_line
            }
        ' "$temp_bashrc" > "${temp_bashrc}.2" || cp "$temp_bashrc" "${temp_bashrc}.2"
        mv "${temp_bashrc}.2" "$temp_bashrc"
        
        # Only replace if we actually removed something or if file is different
        if ! cmp -s "$HOME/.bashrc" "$temp_bashrc"; then
            cp "$HOME/.bashrc" "$HOME/.bashrc.backup.$(date +%s)" 2>/dev/null || true
            mv "$temp_bashrc" "$HOME/.bashrc"
            echo "Cleaned up old completion references from .bashrc"
        else
            rm -f "$temp_bashrc"
        fi
    fi
    
    # Determine the appropriate completion directory
    if [[ -d "/etc/bash_completion.d" ]] && [[ -w "/etc/bash_completion.d" ]]; then
        # System-wide installation (requires write permission)
        COMPLETION_DIR="/etc/bash_completion.d"
    elif [[ -d "$HOME/.local/share/bash-completion/completions" ]]; then
        # User-specific installation (preferred)
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
    else
        # Create user directory if it doesn't exist
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
        mkdir -p "$COMPLETION_DIR"
    fi
    
    # Copy the completion script
    cp "$COMPLETION_SCRIPT" "$COMPLETION_DIR/aixcl"
    chmod +x "$COMPLETION_DIR/aixcl"
    
    echo "‚úÖ Bash completion installed to $COMPLETION_DIR/aixcl"
    echo ""
    echo "To use it immediately in this shell, run:"
    echo "  source $COMPLETION_DIR/aixcl"
    echo ""
    echo "Or restart your shell. It will be automatically loaded in new shell sessions."
    echo ""
    
    # Add to .bashrc
    local bashrc_entry="# Added by aixcl installer
if [ -f \"$COMPLETION_DIR/aixcl\" ]; then
    source \"$COMPLETION_DIR/aixcl\"
fi"
    
    if ! grep -q "Added by aixcl installer" "$HOME/.bashrc" 2>/dev/null; then
        echo "" >> "$HOME/.bashrc"
        echo "$bashrc_entry" >> "$HOME/.bashrc"
        echo "Added sourcing to ~/.bashrc for persistent completion"
    else
        echo "Completion script already referenced in ~/.bashrc"
    fi
}

# get_available_models() is provided by lib/council_utils.sh
# update_env_file() is provided by lib/council_utils.sh

function status_council() {
    echo "üìã LLM Council Status"
    echo "===================="
    echo ""
    
    # Check if services are running
    local llm_council_running=false
    local ollama_running=false
    
    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        llm_council_running=true
    fi
    
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        ollama_running=true
    fi
    
    # Read configuration from .env file
    local council_models=""
    local chairman_model=""
    local backend_mode="ollama"
    # Use SCRIPT_DIR to ensure we're looking in the correct location
    local env_file="${SCRIPT_DIR}/.env"
    
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found."
        echo "   Please run './aixcl stack start' first to create it, then configure the council with './aixcl council configure'"
        return 1
    fi
    
    # Read .env file
    while IFS= read -r line || [ -n "$line" ]; do
        [[ -z "$line" ]] && continue
        [[ "${line#\#}" != "$line" ]] && continue
        
        if [[ "$line" =~ ^BACKEND_MODE[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            backend_mode="${BASH_REMATCH[1]}"
            backend_mode=$(echo "$backend_mode" | xargs | tr -d '"' | tr -d "'")
        elif [[ "$line" =~ ^COUNCIL_MODELS[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            council_models="${BASH_REMATCH[1]}"
            council_models=$(echo "$council_models" | xargs | tr -d '"' | tr -d "'")
        elif [[ "$line" =~ ^CHAIRMAN_MODEL[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            chairman_model="${BASH_REMATCH[1]}"
            chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
        fi
    done < "$env_file"
    
    echo "Configuration:"
    echo "  Backend Mode: ${backend_mode:-ollama}"
    echo ""
    echo "  Chairman: ${chairman_model:-<not set>}"
    echo "  Council Members: ${council_models:-<not set>}"
    echo ""
    
    # Check if council is configured
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "‚ö†Ô∏è  Council is not configured yet."
        echo ""
        echo "To configure the council, run:"
        echo "  ./aixcl council configure"
        return 0
    fi
    
    # Clean up values
    council_models=$(echo "$council_models" | xargs | tr -d '"' | tr -d "'")
    chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
    
    # Build list of all models (avoid duplicates) - use the config we determined above
    local all_models=()
    local seen_models=()
    
    # Add council members
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs | tr -d '"' | tr -d "'")
            if [[ -n "$member" ]]; then
                local already_added=false
                for seen in "${seen_models[@]}"; do
                    if [[ "$seen" == "$member" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ "$already_added" == "false" ]]; then
                    all_models+=("$member")
                    seen_models+=("$member")
                fi
            fi
        done
    fi
    
    # Add chairman if not already in the list
    if [[ -n "$chairman_model" ]]; then
        local already_added=false
        for seen in "${seen_models[@]}"; do
            if [[ "$seen" == "$chairman_model" ]]; then
                already_added=true
                break
            fi
        done
        if [[ "$already_added" == "false" ]]; then
            all_models+=("$chairman_model")
        fi
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured"
        return 1
    fi
    
    # Test operational status for each model
    echo "Operational Status:"
    echo "-------------------"
    echo ""
    
    local operational_count=0
    local total_count=${#all_models[@]}
    
    for model in "${all_models[@]}"; do
        local role="Council Member"
        if [[ "$model" == "$chairman_model" ]]; then
            role="Chairman"
        fi
        
        echo -n "  $model ($role): "
        
        # Test if model is operational
        local is_operational=false
        local status_msg=""
        
        if [[ "$backend_mode" == "ollama" ]] && [[ "$ollama_running" == "true" ]]; then
            # Test model by sending a simple query to Ollama
            local test_payload
            test_payload=$(python3 -c "
import json
import sys
model = sys.argv[1]
payload = {
    'model': model,
    'messages': [{'role': 'user', 'content': 'Say OK'}],
    'stream': False
}
print(json.dumps(payload))
" "$model" 2>/dev/null)
            
            if [[ -n "$test_payload" ]]; then
                local response
                local status_code
                response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:11434/api/chat \
                    -H "Content-Type: application/json" \
                    -d "$test_payload" 2>/dev/null)
                
                status_code=$(echo "$response" | tail -n1)
                response_body=$(echo "$response" | sed '$d')
                
                if [[ "$status_code" == "200" ]] && echo "$response_body" | grep -q "message"; then
                    is_operational=true
                    operational_count=$((operational_count + 1))
                fi
            fi
        elif [[ "$backend_mode" != "ollama" ]]; then
            # For OpenRouter, assume operational (can't test without API key)
            is_operational=true
            operational_count=$((operational_count + 1))
            status_msg=" (OpenRouter - not tested)"
        fi
        
        if [[ "$is_operational" == "true" ]]; then
            echo "‚úÖ Operational$status_msg"
        else
            if [[ "$ollama_running" == "false" ]]; then
                echo "‚ö†Ô∏è  Cannot test (Ollama not running)"
            else
                echo "‚ùå Not Operational"
            fi
        fi
    done
    
    echo ""
    echo "Summary:"
    echo "  Total Models: $total_count"
    echo "  Operational: $operational_count"
    echo "  Not Operational: $((total_count - operational_count))"
    echo ""
    
    # Service status
    if [[ "$llm_council_running" == "true" ]]; then
        echo "‚úÖ LLM-Council service is running"
    else
        echo "‚ö†Ô∏è  LLM-Council service is not running"
    fi
    
    if [[ "$ollama_running" == "true" ]]; then
        echo "‚úÖ Ollama service is running"
    else
        echo "‚ö†Ô∏è  Ollama service is not running"
    fi
    echo ""
}

function test_council_operational() {
    echo "üß™ Testing LLM Council Member Operational Status"
    echo "=============================================="
    echo ""
    
    # Check if LLM-Council service is running
    if ! docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "‚ùå Error: LLM-Council service is not running."
        echo "   Please start the service first with: ./aixcl stack start"
        return 1
    fi
    
    # Check if Ollama is running
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running."
        echo "   Please start the services first with: ./aixcl stack start"
        return 1
    fi
    
    # Get configuration from API
    echo "1. Fetching council configuration from API..."
    local config_response
    config_response=$(curl -s http://localhost:8000/api/config 2>/dev/null)
    
    local council_models=""
    local chairman_model=""
    
    # Try to parse JSON using Python (more reliable than bash regex)
    if command -v python3 >/dev/null 2>&1 && [[ -n "$config_response" ]] && echo "$config_response" | grep -q "council_models"; then
        # Use Python to parse JSON properly
        council_models=$(echo "$config_response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    models = data.get('council_models', [])
    if isinstance(models, list):
        print(','.join(models))
    else:
        print('')
except:
    print('')
" 2>/dev/null)
        
        chairman_model=$(echo "$config_response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data.get('chairman_model', ''))
except:
    print('')
" 2>/dev/null)
    fi
    
    # Fallback to .env file if API parsing failed
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "   ‚ö†Ô∏è  Could not parse API response, reading from .env file..."
        
        local env_file=".env"
        if [[ ! -f "$env_file" ]]; then
            echo "   ‚ùå .env file not found"
            return 1
        fi
        
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            [[ "${line#\#}" != "$line" ]] && continue
            
            if [[ "$line" =~ ^COUNCIL_MODELS[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                council_models="${BASH_REMATCH[1]}"
                council_models=$(echo "$council_models" | xargs)
                if [[ "$council_models" =~ ^\"(.*)\"$ ]]; then
                    council_models="${BASH_REMATCH[1]}"
                elif [[ "$council_models" =~ ^\'(.*)\'$ ]]; then
                    council_models="${BASH_REMATCH[1]}"
                fi
            elif [[ "$line" =~ ^CHAIRMAN_MODEL[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                chairman_model="${BASH_REMATCH[1]}"
                chairman_model=$(echo "$chairman_model" | xargs)
                if [[ "$chairman_model" =~ ^\"(.*)\"$ ]]; then
                    chairman_model="${BASH_REMATCH[1]}"
                elif [[ "$chairman_model" =~ ^\'(.*)\'$ ]]; then
                    chairman_model="${BASH_REMATCH[1]}"
                fi
            fi
        done < "$env_file"
    fi
    
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "   ‚ùå No council configuration found"
        echo "   Please configure the council first with: ./aixcl council configure"
        return 1
    fi
    
    # Clean up extracted values
    council_models=$(echo "$council_models" | xargs)
    chairman_model=$(echo "$chairman_model" | xargs)
    
    echo "   ‚úÖ Configuration loaded"
    echo "   Council Models: $council_models"
    echo "   Chairman Model: $chairman_model"
    echo ""
    
    # Build list of all models to test (avoid duplicates)
    local all_models=()
    local seen_models=()
    
    # Add council members
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs | tr -d '"' | tr -d "'")
            if [[ -n "$member" ]]; then
                # Check if already added
                local already_added=false
                for seen in "${seen_models[@]}"; do
                    if [[ "$seen" == "$member" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ "$already_added" == "false" ]]; then
                    all_models+=("$member")
                    seen_models+=("$member")
                fi
            fi
        done
    fi
    
    # Add chairman if not already in the list
    if [[ -n "$chairman_model" ]]; then
        chairman_model=$(echo "$chairman_model" | xargs | tr -d '"' | tr -d "'")
        local already_added=false
        for seen in "${seen_models[@]}"; do
            if [[ "$seen" == "$chairman_model" ]]; then
                already_added=true
                break
            fi
        done
        if [[ "$already_added" == "false" ]]; then
            all_models+=("$chairman_model")
        fi
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured to test"
        return 1
    fi
    
    if [[ ${#all_models[@]} -eq 0 ]]; then
        echo "‚ùå No models configured to test"
        return 1
    fi
    
    echo "2. Testing ${#all_models[@]} model(s) with a simple query..."
    echo "   Models to test: ${all_models[*]}"
    echo ""
    
    local operational_count=0
    local total_count=${#all_models[@]}
    
    for model in "${all_models[@]}"; do
        local role="Council Member"
        if [[ "$model" == "$chairman_model" ]]; then
            role="Chairman"
        fi
        
        echo -n "   Testing $role: $model... "
        
        # Test model by sending a simple query to Ollama
        # Use Python to properly construct JSON payload to avoid escaping issues
        local test_payload
        test_payload=$(python3 -c "
import json
import sys
model = sys.argv[1]
payload = {
    'model': model,
    'messages': [{'role': 'user', 'content': 'Say OK'}],
    'stream': False
}
print(json.dumps(payload))
" "$model" 2>/dev/null)
        
        if [[ -z "$test_payload" ]]; then
            echo "‚ùå Not Operational"
            echo "      Error: Failed to create test payload"
            continue
        fi
        
        local response
        local status_code
        response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:11434/api/chat \
            -H "Content-Type: application/json" \
            -d "$test_payload" 2>/dev/null)
        
        status_code=$(echo "$response" | tail -n1)
        response_body=$(echo "$response" | sed '$d')
        
        if [[ "$status_code" == "200" ]] && echo "$response_body" | grep -q "message"; then
            echo "‚úÖ Operational"
            operational_count=$((operational_count + 1))
        else
            echo "‚ùå Not Operational"
            if [[ "$status_code" != "200" ]]; then
                echo "      HTTP Status: $status_code"
            fi
            if echo "$response_body" | grep -q "error"; then
                local error_msg
                error_msg=$(echo "$response_body" | grep -o '"error":"[^"]*"' | sed 's/"error":"\(.*\)"/\1/' | head -1)
                [[ -n "$error_msg" ]] && echo "      Error: $error_msg"
            fi
        fi
    done
    
    echo ""
    echo "=" | awk '{printf "=%.0s", $1; for(i=1;i<=65;i++) printf "="; print ""}'
    echo "Summary"
    echo "=" | awk '{printf "=%.0s", $1; for(i=1;i<=65;i++) printf "="; print ""}'
    echo "Total Models: $total_count"
    echo "Operational: $operational_count"
    echo "Not Operational: $((total_count - operational_count))"
    echo ""
    
    if [[ $operational_count -eq $total_count ]]; then
        echo "‚úÖ All council members are operational!"
        return 0
    else
        echo "‚ùå Some council members are not operational"
        echo ""
        echo "Please check:"
        echo "  - Are all models installed in Ollama? (./aixcl models list)"
        echo "  - Are models loaded and ready? (docker logs ollama)"
        echo "  - Check model names match exactly (including tags)"
        return 1
    fi
}

function configure_council() {
    echo "üîß Configuring LLM Council"
    echo "=========================="
    echo ""
    echo "Note: This will ignore any existing .env configuration and create a new one."
    echo ""
    
    # Check if Ollama is running
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running."
        echo "   Please start the services first with: ./aixcl stack start"
        return 1
    fi
    
    # Get available models
    echo "Fetching available models from Ollama..."
    local available_models
    available_models=$(get_available_models)
    
    if [[ -z "$available_models" ]]; then
        echo "‚ùå Error: No models found in Ollama."
        echo "   Please add models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Convert to array for easier handling
    local models_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && models_array+=("$line")
    done <<< "$available_models"
    
    local model_count=${#models_array[@]}
    
    if [[ $model_count -lt 2 ]]; then
        echo "‚ùå Error: At least 2 models are required for the council (1 chairman + 1 member)."
        echo "   You currently have $model_count model(s)."
        echo "   Please add more models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Display available models
    echo ""
    echo "Available models:"
    echo "-----------------"
    local index=1
    for model in "${models_array[@]}"; do
        echo "  [$index] $model"
        ((index++))
    done
    echo ""
    
    # Select chairman
    local chairman_index
    local chairman_model
    while true; do
        read -p "Select chairman model (1-$model_count): " chairman_index || true
        if [[ -z "${chairman_index:-}" ]]; then
            echo ""
            echo "Input cancelled."
            return 1
        fi
        if [[ "$chairman_index" =~ ^[0-9]+$ ]] && [[ "$chairman_index" -ge 1 ]] && [[ "$chairman_index" -le $model_count ]]; then
            chairman_model="${models_array[$((chairman_index - 1))]}"
            echo "‚úÖ Selected chairman: $chairman_model"
            break
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count."
        fi
    done
    
    # Select council members (up to 4 more, for a total of 5)
    local council_members=()
    local max_members=4
    local current_count=0
    local min_members_required=1  # At least 1 member required (plus chairman = 2 total)
    
    echo ""
    echo "Select council members (at least 1 member required, up to $max_members more models):"
    echo "Note: Chairman is already included. Total council size will be 1 + number of members selected."
    echo ""
    
    # Disable exit on error for the interactive loop (we handle errors manually)
    set +e
    
    # Ensure we enter the loop
    while true; do
        local remaining=$((max_members - current_count))
        local total_selected=$((${#council_members[@]} + 1))  # +1 for chairman
        
        if [[ $total_selected -ge 5 ]]; then
            echo ""
            echo "‚úÖ Maximum of 5 models reached (1 chairman + ${#council_members[@]} members)."
            break
        fi
        
        echo ""
        echo "Currently selected:"
        echo "  Chairman: $chairman_model"
        if [[ ${#council_members[@]} -gt 0 ]]; then
            echo "  Members:"
            for member in "${council_members[@]}"; do
                echo "    - $member"
            done
        else
            echo "  Members: (none yet - at least 1 required)"
        fi
        echo ""
        echo "Available models:"
        local available_count=0
        local index=1
        for model in "${models_array[@]}"; do
            local is_selected=0
            local marker=""
            if [[ "$model" == "$chairman_model" ]]; then
                marker=" (chairman)"
                is_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$model" == "$member" ]]; then
                    marker=" (selected)"
                    is_selected=1
                    break
                fi
            done
            if [[ $is_selected -eq 0 ]]; then
                marker=""
                ((available_count++))
            fi
            echo "  [$index] $model$marker"
            ((index++))
        done
        
        if [[ $available_count -eq 0 ]]; then
            echo ""
            echo "  (no more models available)"
            break
        fi
        
        # Build prompt message
        local prompt_msg="Select model (1-$model_count)"
        if [[ ${#council_members[@]} -ge $min_members_required ]]; then
            prompt_msg="$prompt_msg, or 'done' to finish"
            if [[ $remaining -gt 0 ]]; then
                prompt_msg="$prompt_msg [$remaining remaining]"
            fi
        else
            local needed=$((min_members_required - ${#council_members[@]}))
            prompt_msg="$prompt_msg (at least $needed more required)"
        fi
        prompt_msg="$prompt_msg: "
        
        echo ""
        read -p "$prompt_msg" selection || true
        if [[ -z "${selection:-}" ]]; then
            echo ""
            echo "Input cancelled."
            return 1
        fi
        
        # Handle 'done' option - only allow if minimum members are selected
        if [[ "$selection" == "done" ]] || [[ "$selection" == "d" ]]; then
            if [[ ${#council_members[@]} -lt $min_members_required ]]; then
                local needed=$((min_members_required - ${#council_members[@]}))
                echo "‚ùå At least $needed more member(s) required. Please select more models."
                continue
            else
                echo "‚úÖ Finished selecting council members."
                break
            fi
        fi
        
        # Validate numeric selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $model_count ]]; then
            local selected_model="${models_array[$((selection - 1))]}"
            
            # Check if already selected
            local already_selected=0
            if [[ "$selected_model" == "$chairman_model" ]]; then
                already_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$selected_model" == "$member" ]]; then
                    already_selected=1
                    break
                fi
            done
            
            if [[ $already_selected -eq 1 ]]; then
                echo "‚ùå Model '$selected_model' is already selected. Please choose a different model."
            else
                council_members+=("$selected_model")
                echo "‚úÖ Added '$selected_model' to council members"
                ((current_count++))
            fi
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count"
            if [[ ${#council_members[@]} -ge $min_members_required ]]; then
                echo "   or type 'done' to finish."
            fi
        fi
    done
    
    # Re-enable exit on error
    set -e
    
    # Validate we have at least 2 models (chairman + at least 1 member)
    local total_models=$((${#council_members[@]} + 1))
    if [[ $total_models -lt 2 ]]; then
        echo ""
        echo "‚ùå Error: Council must have at least 2 models (1 chairman + 1 member)."
        echo "   You selected only the chairman."
        return 1
    fi
    
    # Build council models string (comma-separated, excluding chairman)
    local council_models_str=""
    for member in "${council_members[@]}"; do
        if [[ -z "$council_models_str" ]]; then
            council_models_str="$member"
        else
            council_models_str="$council_models_str,$member"
        fi
    done
    
    # Show summary
    echo ""
    echo "=========================="
    echo "Council Configuration Summary"
    echo "=========================="
    echo "Chairman: $chairman_model"
    echo "Council Members (${#council_members[@]}):"
    for member in "${council_members[@]}"; do
        echo "  - $member"
    done
    echo "Total models: $total_models"
    echo ""
    echo "This will update .env file with:"
    echo "  - CHAIRMAN_MODEL: $chairman_model"
    echo "  - COUNCIL_MODELS: $council_models_str"
    echo ""
    echo "‚ö†Ô∏è  Note: Any existing council configuration in .env will be replaced."
    echo ""
    
    # Ask for confirmation
    read -p "Apply this configuration? (yes/no): " confirm || true
    if [[ "${confirm:-}" != "yes" ]] && [[ "${confirm:-}" != "y" ]]; then
        echo "Configuration cancelled."
        return 0
    fi
    
    # Update .env file for persistence (this will overwrite existing values)
    if ! update_env_file "$council_models_str" "$chairman_model"; then
        return 1
    fi
    
    echo ""
    echo "‚úÖ Council configuration updated successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Restart the LLM-Council service to apply changes:"
    echo "     ./aixcl stack restart"
    echo "  2. The configuration will be loaded automatically"
    echo ""
    
    # Ask if user wants to restart services
    read -p "Restart LLM-Council service now? (yes/no): " restart_confirm || true
    if [[ "${restart_confirm:-}" == "yes" ]] || [[ "${restart_confirm:-}" == "y" ]]; then
        echo ""
        echo "Restarting LLM-Council service to apply new configuration..."
        set_compose_cmd
        # Stop if running
        if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
            run_compose stop llm-council 2>/dev/null || true
        fi
        # Always remove the container to avoid docker-compose ContainerConfig KeyError
        # when using images from registry (older docker-compose versions have this bug)
        # This also handles the case where container exists but is stopped
        run_compose rm -f llm-council 2>/dev/null || docker rm -f llm-council 2>/dev/null || true
        run_compose build llm-council
        run_compose up -d llm-council
        echo "‚úÖ LLM-Council service restarted with new configuration"
    fi
    return 0
}

function utils_cmd() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Utils action is required"
        echo "Usage: $0 utils {check-env|bash-completion}"
        echo "Examples:"
        echo "  $0 utils check-env         - Verify environment setup"
        echo "  $0 utils bash-completion   - Install bash completion"
        return 1
    fi

    local action="$1"
    shift

    # Check for extra arguments
    if [ $# -gt 0 ]; then
        echo "Error: Unknown argument '$1'"
        echo "Usage: $0 utils {check-env|bash-completion}"
        return 1
    fi

    case "$action" in
        check-env)
            check_env
            ;;
        bash-completion)
            install_completion
            ;;
        *)
            echo "Error: Unknown utils action '$action'"
            echo "Usage: $0 utils {check-env|bash-completion}"
            echo "Examples:"
            echo "  $0 utils check-env         - Verify environment setup"
            echo "  $0 utils bash-completion   - Install bash completion"
            return 1
            ;;
    esac
}

function stack_cmd() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Stack action is required"
        echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
        echo "Examples:"
        echo "  $0 stack start                - Start all services with sys profile (default)"
        echo "  $0 stack start --profile usr  - Start runtime core + PostgreSQL (minimal footprint)"
        echo "  $0 stack start --profile dev  - Start dev profile (runtime core + UI + DB)"
        echo "  $0 stack start --profile ops  - Start ops profile (runtime core + observability)"
        echo "  $0 stack start --profile sys  - Start all services"
        echo "  $0 stack stop                 - Stop all services"
        echo "  $0 stack restart [--profile <profile>] [service1] [service2] ... - Restart stack or specific services"
        echo "  $0 stack status               - Show service status (runtime core vs operational)"
        echo "  $0 stack logs                 - Show logs for all services"
        echo "  $0 stack logs ollama          - Show logs for a specific service"
        echo "  $0 stack logs ollama 100      - Show last 100 lines for a service"
        echo "  $0 stack clean                - Remove unused Docker resources"
        echo ""
        echo "Valid profiles: usr, dev, ops, sys (default: sys)"
        echo "For detailed profile definitions, see: docs/architecture/governance/02_profiles.md"
        return 1
    fi

    local action="$1"
    shift

    case "$action" in
        start)
            start "$@"
            ;;
        stop)
            if [ $# -gt 0 ]; then
                echo "Error: Unknown argument '$1'"
                echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
                return 1
            fi
            stop
            ;;
        restart)
            restart "$@"
            ;;
        status)
            if [ $# -gt 0 ]; then
                echo "Error: Unknown argument '$1'"
                echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
                return 1
            fi
            status
            ;;
        logs)
            logs "$@"
            ;;
        clean)
            if [ $# -gt 0 ]; then
                echo "Error: Unknown argument '$1'"
                echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
                return 1
            fi
            clean
            ;;
        *)
            echo "Error: Unknown stack action '$action'"
            echo "Usage: $0 stack {start|stop|restart|status|logs|clean}"
            echo ""
            echo "For profiles and service contracts, see: docs/architecture/governance/"
            return 1
            ;;
    esac
}

function council_cmd() {
    # Require an action - show usage if none provided
    if [[ $# -lt 1 ]]; then
        echo "Error: Council action is required"
        echo "Usage: $0 council [configure|status]"
        echo "Examples:"
        echo "  $0 council status     - Show council configuration and operational status"
        echo "  $0 council configure  - Configure council models and chairman"
        return 1
    fi

    local action="$1"
    shift

    # Check for extra arguments
    if [ $# -gt 0 ]; then
        echo "Error: Unknown argument '$1'"
        echo "Usage: $0 council [configure|status]"
        return 1
    fi

    case "$action" in
        configure)
            configure_council
            ;;
        status)
            status_council
            ;;
        *)
            echo "Error: Unknown council action '$action'"
            echo "Usage: $0 council [configure|status]"
            echo "Examples:"
            echo "  $0 council status     - Show council configuration and operational status"
            echo "  $0 council configure  - Configure council models and chairman"
            return 1
            ;;
    esac
}

# ‚îÄ‚îÄ System prompt for clean Goose/Ollama query output ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
QUERY_SYSTEM_PROMPT="Answer directly and concisely. No preamble, no restating the question. Use plain text unless code is explicitly requested. Use bullet points for lists. Do not add disclaimers or offer further help."

function query_cmd() {
    # Check if goose is installed
    if ! command -v goose >/dev/null 2>&1; then
        print_error "Goose CLI is not installed. See docs/developer/goose-setup.md"
        return 1
    fi

    # Handle subcommands and options
    local session_mode=false
    local text_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            session)
                session_mode=true
                shift
                ;;
            -h|--help)
                echo "Usage: $0 query [options] <question>"
                echo ""
                echo "Send a query to the local LLM via Goose with clean output."
                echo ""
                echo "Options:"
                echo "  session                     - Start an interactive Goose session"
                echo "  <question>                  - One-shot query (returns answer and exits)"
                echo ""
                echo "Examples:"
                echo "  $0 query 'What is a Kubernetes pod?'"
                echo "  $0 query session"
                echo "  echo 'Explain Docker volumes' | $0 query -"
                return 0
                ;;
            *)
                text_args+=("$1")
                shift
                ;;
        esac
    done

    if [[ "$session_mode" == "true" ]]; then
        # Interactive session with system prompt (extensions loaded from profile)
        exec goose session --system "$QUERY_SYSTEM_PROMPT"
    fi

    # One-shot query mode
    if [[ ${#text_args[@]} -eq 0 ]]; then
        echo "Error: No query provided"
        echo "Usage: $0 query <question>"
        echo "       $0 query session"
        return 1
    fi

    local query_text="${text_args[*]}"

    # Handle stdin piping (aixcl query -)
    if [[ "$query_text" == "-" ]]; then
        query_text=$(cat)
        if [[ -z "$query_text" ]]; then
            print_error "No input received from stdin"
            return 1
        fi
    fi

    # Run in quiet mode with --no-profile to disable all extensions (pure chat,
    # no tool calls). This avoids tool-call JSON parsing errors from the model.
    goose run --quiet --no-session --no-profile \
        --system "$QUERY_SYSTEM_PROMPT" \
        --text "$query_text"
}

function main() {
    if [[ $# -lt 1 ]]; then
        help_menu
    fi

    case "$1" in
        service)
            shift
            service "$@"
            ;;
        models)
            shift
            models "$@"
            ;;
        dashboard)
            shift
            dashboard "$@"
            ;;
        query)
            shift
            query_cmd "$@"
            ;;
        help)
            help_menu
            ;;
        bash-completion)
            install_completion
            ;;
        check-env)
            check_env
            ;;
        utils)
            shift
            utils_cmd "$@"
            ;;
        stack)
            shift
            stack_cmd "$@"
            ;;
        council)
            shift
            council_cmd "$@"
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            help_menu
            ;;
    esac
}

main "$@"
