
#!/usr/bin/env bash

set -e  # Exit on error
set -u  # Treat unset variables as an error
set -o pipefail  # Catch errors in pipelines

# Safe function to load environment variables from .env file
load_env_file() {
    local env_file="$1"
    if [ -f "$env_file" ]; then
        # Use a safer method to parse .env files
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and comments
            [ -z "$line" ] && continue
            [ "${line#\#}" != "$line" ] && continue
            
            # Extract key and value, handling quoted values
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                
                # Remove leading/trailing whitespace from key
                key="${key%"${key##*[![:space:]]}"}"
                key="${key#"${key%%[![:space:]]*}"}"
                
                # Remove leading/trailing whitespace from value
                value="${value%"${value##*[![:space:]]}"}"
                value="${value#"${value%%[![:space:]]*}"}"
                
                # Remove surrounding quotes if present
                if [[ "$value" =~ ^\".*\"$ ]]; then
                    value="${value#\"}"
                    value="${value%\"}"
                elif [[ "$value" =~ ^\'.*\'$ ]]; then
                    value="${value#\'}"
                    value="${value%\'}"
                fi
                
                # Only export if key is not empty and contains valid characters
                if [ -n "$key" ] && [[ "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                    export "$key"="$value"
                else
                    echo "‚ö†Ô∏è Skipping invalid environment variable key: '$key'"
                fi
            fi
        done < "$env_file"
    fi
}

# Load environment variables from .env file
load_env_file ".env"

# Allow custom Docker Compose file via environment variable
COMPOSE_FILE=${COMPOSE_FILE:-docker-compose.yml}

# Sanitize COMPOSE_FILE
# Reject any value containing non-alphanumeric, dash, underscore, dot or slash
# Updated regex to properly handle file paths and prevent directory traversal
if [[ ! "$COMPOSE_FILE" =~ ^[A-Za-z0-9._/-]+$ ]] || [[ "$COMPOSE_FILE" =~ \.\. ]] || [[ "$COMPOSE_FILE" =~ ^/ ]]; then
    echo "‚ùå Invalid COMPOSE_FILE value: $COMPOSE_FILE"
    echo "   Allowed characters: A-Z, a-z, 0-9, ., _, -, /"
    echo "   Cannot start with / or contain .."
    exit 1
fi

# Use array for safer command construction
COMPOSE_CMD=(docker-compose -f "$COMPOSE_FILE")
CONTAINER_NAME="open-webui"

# Define all services from docker-compose.yml
# This list should match the services defined in docker-compose.yml
ALL_SERVICES=(
    "ollama"
    "open-webui"
    "postgres"
    "pgadmin"
    "watchtower"
    "prometheus"
    "grafana"
    "cadvisor"
    "node-exporter"
    "postgres-exporter"
    "nvidia-gpu-exporter"
    "loki"
    "promtail"
)

# Function to validate service name
function is_valid_service() {
    local service="$1"
    for valid_service in "${ALL_SERVICES[@]}"; do
        if [ "$service" = "$valid_service" ]; then
            return 0
        fi
    done
    return 1
}

# Function to get container name from service name
function get_container_name() {
    local service="$1"
    case "$service" in
        "open-webui")
            echo "open-webui"
            ;;
        "node-exporter")
            echo "node-exporter"
            ;;
        "postgres-exporter")
            echo "postgres-exporter"
            ;;
        "nvidia-gpu-exporter")
            echo "nvidia-gpu-exporter"
            ;;
        *)
            echo "$service"
            ;;
    esac
}

# Detect if NVIDIA GPU is available
function has_nvidia() {
    if command -v nvidia-smi >/dev/null 2>&1; then
        nvidia-smi >/dev/null 2>&1 && return 0 || return 1
    fi
    if docker info 2>/dev/null | grep -qi "nvidia"; then
        return 0
    fi
    return 1
}

# Detect if running on ARM64 architecture
function is_arm64() {
    local arch=$(uname -m)
    case "$arch" in
        arm64|aarch64)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Build docker-compose command with optional GPU and ARM overrides if present
function set_compose_cmd() {
    local files=( -f "$COMPOSE_FILE" )
    
    # Check for ARM64 architecture
    if is_arm64 && [ -f docker-compose.arm.yml ]; then
        echo "Detected ARM64 architecture. Enabling ARM platform overrides."
        files+=( -f docker-compose.arm.yml )
    fi
    
    # Check for NVIDIA GPU
    if has_nvidia && [ -f docker-compose.gpu.yml ]; then
        echo "Detected NVIDIA GPU. Enabling GPU overrides."
        files+=( -f docker-compose.gpu.yml )
    else
        echo "No NVIDIA GPU detected. Running without GPU overrides."
    fi
    
    COMPOSE_CMD=(docker-compose "${files[@]}")
}

# Source the autocomplete script if it exists (with security validation)
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
COMPLETION_SCRIPT="${SCRIPT_DIR}/aixcl_completion.sh"
if [ -f "$COMPLETION_SCRIPT" ] && [[ "$COMPLETION_SCRIPT" =~ ^/ ]] && [ -r "$COMPLETION_SCRIPT" ]; then
    source "$COMPLETION_SCRIPT"
fi

function check_env() {
    echo "Checking environment dependencies..."
    local missing_deps=0

    local is_wsl=0
    if grep -qi "microsoft" /proc/sys/kernel/osrelease 2>/dev/null || \
       grep -qi "microsoft" /proc/version 2>/dev/null; then
        is_wsl=1
        echo "‚ÑπÔ∏è  Windows Subsystem for Linux detected. GPU checks rely on nvidia-smi/docker instead of lspci."
    fi

    # Check Docker
    if ! command -v docker &> /dev/null; then
        echo "‚ùå Docker is not installed"
        echo "   Install from: https://docs.docker.com/get-docker/"
        missing_deps=1
    else
        echo "‚úÖ Docker is installed"
        # Check if Docker daemon is running
        if ! docker info &> /dev/null; then
            echo "‚ùå Docker daemon is not running"
            echo "   Start with: sudo systemctl start docker"
            missing_deps=1
        else
            echo "‚úÖ Docker daemon is running"
        fi
    fi

    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        echo "‚ùå Docker Compose is not installed"
        echo "   Install from: https://docs.docker.com/compose/install/"
        missing_deps=1
    else
        echo "‚úÖ Docker Compose is installed"
    fi

    # Check Bash shell
    echo -e "\nChecking shell environment..."
    if ! command -v bash &> /dev/null; then
        echo "‚ùå Bash shell is not installed"
        echo "   Install bash to continue: https://www.gnu.org/software/bash/"
        missing_deps=1
    else
        echo "‚úÖ Bash shell is available"
    fi

    # Check NVIDIA drivers and toolkit (optional)
    echo -e "\nChecking NVIDIA support..."
    local os_id=""
    local os_pretty=""
    if [ -f /etc/os-release ]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        os_id="${ID:-}"
        os_pretty="${PRETTY_NAME:-$os_id}"
    fi

    if [ -n "$os_pretty" ]; then
        echo "Detected operating system: $os_pretty"
    else
        echo "‚ö†Ô∏è Could not determine operating system (using generic GPU checks)"
    fi

    local has_gpu_hardware=0
    if command -v lspci &> /dev/null; then
        if lspci | grep -qi "nvidia"; then
            echo "‚úÖ NVIDIA GPU hardware detected"
            has_gpu_hardware=1
        else
            echo "‚ö†Ô∏è NVIDIA GPU hardware not detected"
        fi
    else
        if [ "$is_wsl" -eq 1 ]; then
            echo "‚ö†Ô∏è lspci is unavailable in WSL; falling back to runtime detection."
            if command -v nvidia-smi &> /dev/null && nvidia-smi &> /dev/null; then
                echo "‚úÖ NVIDIA GPU support detected via nvidia-smi"
                has_gpu_hardware=1
            elif [ -e /dev/dxg ]; then
                echo "‚úÖ NVIDIA GPU hardware exposed via /dev/dxg"
                has_gpu_hardware=1
            elif has_nvidia; then
                echo "‚úÖ NVIDIA GPU support detected via Docker runtime checks"
                has_gpu_hardware=1
            else
                echo "‚ÑπÔ∏è  Unable to confirm NVIDIA GPU support in WSL."
                echo "   If you expect GPU access, ensure you've installed the Windows CUDA drivers"
                echo "   and enabled GPU sharing in WSL: https://learn.microsoft.com/windows/wsl/tutorials/gpu-compute"
            fi
        else
            echo "‚ö†Ô∏è Unable to detect GPU hardware (missing lspci command)"
            echo "   Install pciutils to enable hardware detection (e.g., sudo apt install pciutils)"
        fi
    fi

    if command -v nvidia-smi &> /dev/null; then
        echo "‚úÖ NVIDIA drivers installed"
    elif [ "$has_gpu_hardware" -eq 1 ]; then
        echo "‚ùå NVIDIA drivers not found"
        case "$os_id" in
            ubuntu|debian)
                echo "   Install drivers with: sudo ubuntu-drivers autoinstall"
                ;;
            fedora)
                echo "   Install drivers with RPM Fusion: sudo dnf install akmod-nvidia xorg-x11-drv-nvidia-cuda"
                ;;
            *)
                echo "   Refer to NVIDIA docs for driver installation: https://www.nvidia.com/Download/index.aspx"
                ;;
        esac
    else
        echo "‚ö†Ô∏è NVIDIA drivers not found (no GPU detected)"
    fi

    # Check NVIDIA Container Toolkit
    if command -v nvidia-container-cli &> /dev/null; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    elif command -v dpkg &> /dev/null && dpkg -l | grep -q nvidia-container-toolkit; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    elif command -v rpm &> /dev/null && rpm -qa | grep -q nvidia-container-toolkit; then
        echo "‚úÖ NVIDIA Container Toolkit installed"
    else
        echo "‚ö†Ô∏è NVIDIA Container Toolkit not found (optional)"
        case "$os_id" in
            ubuntu|debian)
                echo "   Install toolkit with:"
                echo "   sudo apt update && sudo apt install -y nvidia-container-toolkit"
                ;;
            fedora)
                echo "   Install toolkit with:"
                echo "   sudo dnf config-manager --add-repo https://nvidia.github.io/libnvidia-container/stable/fedora/libnvidia-container.repo"
                echo "   sudo dnf install -y nvidia-container-toolkit"
                ;;
            *)
                echo "   Install instructions: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html"
                ;;
        esac
    fi

    # Check available disk space
    echo -e "\nChecking system resources..."
    local required_space=10 # GB
    local available_space=$(df -BG "$(pwd)" | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [ "$available_space" -lt "$required_space" ]; then
        echo "‚ùå Insufficient disk space. Required: ${required_space}GB, Available: ${available_space}GB"
        missing_deps=1
    else
        echo "‚úÖ Sufficient disk space available"
    fi

    # Check memory
    local total_mem=$(free -g | awk '/^Mem:/{print $2}')
    if [ "$total_mem" -lt 8 ]; then
        echo "‚ö†Ô∏è Low memory detected (${total_mem}GB). Recommended: 8GB+"
    else
        echo "‚úÖ Sufficient memory available"
    fi

    if [ $missing_deps -eq 1 ]; then
        echo -e "\n‚ùå Environment check failed. Please address the issues above."
        return 1
    else
        echo -e "\n‚úÖ Environment check passed! You're ready to run AIXCL."
        return 0
    fi
}

function generate_pgadmin_config() {
    echo "Generating pgAdmin server configuration..."
    
    # Validate required environment variables
    if [ -z "${POSTGRES_USER}" ] || [ -z "${POSTGRES_PASSWORD}" ]; then
        echo "‚ùå Error: POSTGRES_USER and POSTGRES_PASSWORD must be set in .env file"
        echo "   Please check your .env file and ensure these variables are configured"
        return 1
    fi
    
    # Create pgadmin-servers.json with populated environment values
    cat > pgadmin-servers.json << EOF
{
  "Servers": {
    "1": {
      "Group": "Servers",
      "Name": "AIXCL",
      "Host": "localhost",
      "Port": 5432,
      "MaintenanceDB": "postgres",
      "Username": "${POSTGRES_USER}",
      "Password": "${POSTGRES_PASSWORD}",
      "SSLMode": "prefer",
      "Favorite": true
    }
  }
}
EOF
    
    # Set restrictive file permissions (read/write for owner only)
    chmod 600 pgadmin-servers.json
    
    echo "‚úÖ Generated pgadmin-servers.json with populated values and secure permissions"
}

function start() {
    echo "Starting Docker Compose deployment..."
    
    # Check for .env file and create from .env.example if missing
    if [ ! -f .env ]; then
        if [ -f .env.example ]; then
            echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
            cp .env.example .env
            echo "‚úÖ Created .env file from .env.example"
            # Reload environment variables after creating .env file
            load_env_file ".env"
        else
            echo "‚ùå Error: Neither .env nor .env.example file found"
            echo "   Please create a .env file with the required configuration"
            exit 1
        fi
    fi
    
    # Generate pgAdmin configuration with populated values
    generate_pgadmin_config
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "Services are already running. Use 'stop' first if you want to restart."
        exit 1
    fi
    
    echo "Pulling latest images..."
    "${COMPOSE_CMD[@]}" pull
    
    echo "Starting services..."
    "${COMPOSE_CMD[@]}" up -d
    
    echo "Waiting for services to be ready..."
    for i in {1..30}; do
        if            curl -s -o /dev/null -w "%{http_code}" http://localhost:11434/api/version 2>/dev/null | grep -q "200" && \
           curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 2>/dev/null | grep -q "200" && \
           curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null | grep -q "200" && \
           docker exec postgres pg_isready -U webui >/dev/null 2>&1; then
            echo "All services are up and running!"
            status
            return 0
        fi
        echo "Waiting for services to become available... ($i/30)"
        sleep 2
    done
    
    echo "Error: Services did not start properly within timeout period"
    status
    exit 1
}

function stop() {
    echo "Stopping Docker Compose deployment..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
        echo "Services are not running."
        return 0
    fi
    
    echo "Stopping services gracefully..."
    "${COMPOSE_CMD[@]}" down --remove-orphans
    
    echo "Waiting for containers to stop..."
    for i in {1..15}; do
        if ! docker ps --format "{{.Names}}" | grep -qE "$CONTAINER_NAME|ollama|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter"; then
            echo "All services stopped successfully."
            return 0
        fi
        echo "Waiting for services to stop... ($i/15)"
        sleep 2
    done
    
    echo "Warning: Services did not stop gracefully. Forcing shutdown..."
    "${COMPOSE_CMD[@]}" down --remove-orphans -v
    docker ps -q | xargs -r docker stop
    
    echo "All services have been stopped."
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
}

function restart() {
    echo "Restarting services..."
    stop
    sleep 5
    start
}

function start_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service start <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local service="$1"
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Check if service is already running
    if docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Service '$service' is already running."
        return 0
    fi
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Starting service: $service..."
    
    # Check for .env file if needed (for services that require it)
    if [ ! -f .env ] && [ "$service" = "open-webui" ] || [ "$service" = "postgres" ] || [ "$service" = "pgadmin" ]; then
        if [ -f .env.example ]; then
            echo "‚ö†Ô∏è  .env file not found. Copying from .env.example..."
            cp .env.example .env
            load_env_file ".env"
        else
            echo "‚ùå Error: .env file required for service '$service'"
            return 1
        fi
    fi
    
    # Generate pgAdmin configuration if starting pgadmin
    if [ "$service" = "pgadmin" ]; then
        generate_pgadmin_config
    fi
    
    # Start the specific service
    if "${COMPOSE_CMD[@]}" up -d "$service"; then
        echo "‚úÖ Successfully started service: $service"
        
        # Wait a moment for the service to initialize
        sleep 2
        
        # Check if the container is actually running
        if docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
            echo "Service '$service' is now running."
        else
            echo "‚ö†Ô∏è  Service '$service' may not have started correctly. Check logs with: $0 logs $service"
        fi
        return 0
    else
        echo "‚ùå Failed to start service: $service"
        return 1
    fi
}

function stop_service() {
    if [ -z "$1" ]; then
        echo "Error: Service name is required"
        echo "Usage: $0 service stop <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local service="$1"
    
    # Validate service name
    if ! is_valid_service "$service"; then
        echo "‚ùå Error: Unknown service '$service'"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local container_name=$(get_container_name "$service")
    
    # Check if service is running
    if ! docker ps --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Service '$service' is not running."
        return 0
    fi
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping service: $service..."
    
    # Stop the specific service
    if "${COMPOSE_CMD[@]}" stop "$service"; then
        echo "‚úÖ Successfully stopped service: $service"
        
        # Clean up pgAdmin configuration if stopping pgadmin
        if [ "$service" = "pgadmin" ] && [ -f "pgadmin-servers.json" ]; then
            rm -f pgadmin-servers.json
            echo "üßπ Cleaned up pgAdmin configuration file"
        fi
        return 0
    else
        echo "‚ùå Failed to stop service: $service"
        return 1
    fi
}

function service() {
    if [[ $# -lt 2 ]]; then
        echo "Error: Service action and name are required"
        echo "Usage: $0 service {start|stop|restart} <service-name>"
        echo "Available services: ${ALL_SERVICES[*]}"
        return 1
    fi
    
    local action="$1"
    local service="$2"
    
    case "$action" in
        start)
            start_service "$service"
            ;;
        stop)
            stop_service "$service"
            ;;
        restart)
            stop_service "$service"
            sleep 2
            start_service "$service"
            ;;
        *)
            echo "Error: Unknown service action '$action'"
            echo "Available actions: start, stop, restart"
            return 1
            ;;
    esac
}

function logs() {
    # Set up compose command with GPU detection
    set_compose_cmd
    
    if [ $# -eq 0 ]; then
        echo "Fetching logs for all services..."
        "${COMPOSE_CMD[@]}" logs --tail=0 --follow
    else
        local container="$1"
        local tail_count="${2:-50}"  # Default to 50 lines if not specified
        
        # Validate tail_count
        if [[ ! "$tail_count" =~ ^[0-9]+$ ]] || [[ "$tail_count" -lt 1 ]] || [[ "$tail_count" -gt 10000 ]]; then
            echo "‚ùå tail count must be a number between 1 and 10000"
            return 1
        fi
        
        # Validate container name
        case "$container" in
            ollama|open-webui|postgres|pgadmin|llm-council|watchtower|prometheus|grafana|cadvisor|node-exporter|postgres-exporter|nvidia-gpu-exporter)
                echo "Fetching logs for $container..."
                docker logs "$container" --tail="$tail_count" --follow
                ;;
            *)
                echo "Error: Unknown container '$container'"
                echo "Available containers: ollama, open-webui, postgres, pgadmin, llm-council, watchtower, prometheus, grafana, cadvisor, node-exporter, postgres-exporter, nvidia-gpu-exporter"
                return 1
                ;;
        esac
    fi
}

function clean() {
    echo "Cleaning up Docker resources..."
    
    # Set up compose command with GPU detection
    set_compose_cmd
    
    echo "Stopping all containers..."
    "${COMPOSE_CMD[@]}" down
    
    echo "Removing stopped containers..."
    docker container prune -f
    
    echo "Removing unused images..."
    docker image prune -a -f
    
    echo "Removing unused volumes (including PostgreSQL data)..."
    docker volume prune -f
    
    # Clean up pgAdmin configuration file for security
    if [ -f "pgadmin-servers.json" ]; then
        rm -f pgadmin-servers.json
        echo "üßπ Cleaned up pgAdmin configuration file"
    fi
    
    echo "Clean up complete."
}

function status() {
    echo "Checking services status..."
    
    echo "Container Status:"
    echo "----------------"
    if docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "‚úÖ Open WebUI container is running"
    else
        echo "‚ùå Open WebUI container is not running"
    fi
    
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚úÖ Ollama container is running"
    else
        echo "‚ùå Ollama container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "postgres"; then
        echo "‚úÖ PostgreSQL container is running"
    else
        echo "‚ùå PostgreSQL container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "pgadmin"; then
        echo "‚úÖ pgAdmin container is running"
    else
        echo "‚ùå pgAdmin container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "‚úÖ LLM-Council container is running"
    else
        echo "‚ùå LLM-Council container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "watchtower"; then
        echo "‚úÖ Watchtower container is running"
    else
        echo "‚ùå Watchtower container is not running"
    fi

    # Monitoring services
    if docker ps --format "{{.Names}}" | grep -q "prometheus"; then
        echo "‚úÖ Prometheus container is running"
    else
        echo "‚ùå Prometheus container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "grafana"; then
        echo "‚úÖ Grafana container is running"
    else
        echo "‚ùå Grafana container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "cadvisor"; then
        echo "‚úÖ cAdvisor container is running"
    else
        echo "‚ùå cAdvisor container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "node-exporter"; then
        echo "‚úÖ Node Exporter container is running"
    else
        echo "‚ùå Node Exporter container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "postgres-exporter"; then
        echo "‚úÖ Postgres Exporter container is running"
    else
        echo "‚ùå Postgres Exporter container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "nvidia-gpu-exporter"; then
        echo "‚úÖ NVIDIA GPU Exporter container is running"
    else
        echo "‚ö†Ô∏è  NVIDIA GPU Exporter container is not running (expected on non-GPU systems)"
    fi

    if docker ps --format "{{.Names}}" | grep -q "loki"; then
        echo "‚úÖ Loki container is running"
    else
        echo "‚ùå Loki container is not running"
    fi

    if docker ps --format "{{.Names}}" | grep -q "promtail"; then
        echo "‚úÖ Promtail container is running"
    else
        echo "‚ùå Promtail container is not running"
    fi
    
    echo -e "\nService Health:"
    echo "----------------"
    
    if curl -s -o /dev/null -w "%{http_code}" http://localhost:11434/api/version 2>/dev/null | grep -q "200"; then
        echo "‚úÖ Ollama API is responding"
    else
        echo "‚ùå Ollama API is not responding"
    fi
    
    echo -n "Open WebUI status: "
    WEBUI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null)
    if [ "$WEBUI_STATUS" = "200" ]; then
        echo "‚úÖ Open WebUI is responding (HTTP 200)"
    else
        echo "‚ùå Open WebUI is not responding (HTTP $WEBUI_STATUS)"
        echo "Checking container logs:"
        docker logs "$CONTAINER_NAME" --tail 5
    fi

    echo -n "PostgreSQL status: "
    if docker exec postgres pg_isready -U "${POSTGRES_USER:-webui}" >/dev/null 2>&1; then
        echo "‚úÖ PostgreSQL is responding"
    else
        echo "‚ùå PostgreSQL is not responding"
        echo "Checking PostgreSQL logs:"
        docker logs postgres --tail 5
    fi

    echo -n "pgAdmin status: "
    PGADMIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null)
    if [ "$PGADMIN_STATUS" = "200" ] || [ "$PGADMIN_STATUS" = "302" ]; then
        echo -e "‚úÖ pgAdmin is responding (HTTP $PGADMIN_STATUS)"
    else
        echo -e "‚ùå pgAdmin is not responding (HTTP $PGADMIN_STATUS)"
        echo "Checking pgAdmin logs:"
        docker logs pgadmin --tail 5
    fi

    echo -n "LLM-Council status: "
    COUNCIL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null)
    if [ "$COUNCIL_STATUS" = "200" ]; then
        echo -e "‚úÖ LLM-Council is responding (HTTP $COUNCIL_STATUS)"
    else
        echo -e "‚ùå LLM-Council is not responding (HTTP $COUNCIL_STATUS)"
        echo "Checking LLM-Council logs:"
        docker logs llm-council --tail 5 2>/dev/null || echo "  (Container may not be running)"
    fi

    echo -n "Prometheus status: "
    PROMETHEUS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9090/-/healthy 2>/dev/null)
    if [ "$PROMETHEUS_STATUS" = "200" ]; then
        echo "‚úÖ Prometheus is responding (HTTP $PROMETHEUS_STATUS)"
    else
        echo "‚ùå Prometheus is not responding (HTTP $PROMETHEUS_STATUS)"
    fi

    echo -n "Grafana status: "
    GRAFANA_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null)
    if [ "$GRAFANA_STATUS" = "200" ]; then
        echo "‚úÖ Grafana is responding (HTTP $GRAFANA_STATUS)"
    else
        echo "‚ùå Grafana is not responding (HTTP $GRAFANA_STATUS)"
    fi

    echo -n "Loki status: "
    LOKI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3100/ready 2>/dev/null)
    if [ "$LOKI_STATUS" = "200" ]; then
        echo "‚úÖ Loki is responding (HTTP $LOKI_STATUS)"
    else
        echo "‚ùå Loki is not responding (HTTP $LOKI_STATUS)"
    fi

    echo -n "Promtail status: "
    if docker ps --format "{{.Names}}" | grep -q "^promtail$"; then
        if docker exec promtail wget --no-verbose --tries=1 --spider http://localhost:9080/ready 2>/dev/null; then
            echo "‚úÖ Promtail is responding"
        else
            echo "‚ö†Ô∏è  Promtail container is running but health check failed"
        fi
    else
        echo "‚ùå Promtail container is not running"
    fi
    echo ""
}

function add() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models add <model-name> [<model-name> ...]"
        echo "Example: $0 models add starcoder2:latest"
        echo "Example: $0 models add starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Adding model: $1"
    
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec ollama ollama pull "$1"; then
        echo "‚úÖ Successfully added model: $1"
    else
        echo "‚ùå Failed to add model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function remove() {
    if [ -z "$1" ]; then
        echo "Error: Model name is required"
        echo "Usage: $0 models remove <model-name> [<model-name> ...]"
        echo "Example: $0 models remove starcoder2:latest"
        echo "Example: $0 models remove starcoder2:latest nomic-embed-text:latest"
        return 1
    fi

    # Validate model name format
    if [[ ! "$1" =~ ^[A-Za-z0-9._-]+(:[A-Za-z0-9._-]+)?$ ]]; then
        echo "‚ùå Invalid model name format: '$1'"
        echo "   Model names should contain only alphanumeric characters, dots, underscores, dashes"
        echo "   Optional tag format: model:tag (e.g., starcoder2:latest)"
        return 1
    fi

    echo "Removing model: $1"
    
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    if docker exec ollama ollama rm "$1"; then
        echo "‚úÖ Successfully removed model: $1"
    else
        echo "‚ùå Failed to remove model: $1"
        echo "Debug: Check if the model name is correct and the Ollama container is running."
        return 1
    fi
}

function models() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Models action is required"
        echo "Usage: $0 models {add|remove|list} [<model-name> ...]"
        echo "Examples:"
        echo "  $0 models add starcoder2:latest"
        echo "  $0 models remove starcoder2:latest nomic-embed-text:latest"
        echo "  $0 models list"
        return 1
    fi

    local action="$1"
    shift

    local status=0

    case "$action" in
        add)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for add"
                echo "Usage: $0 models add <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! add "$model"; then
                    status=1
                fi
            done
            ;;
        remove)
            if [[ $# -lt 1 ]]; then
                echo "Error: At least one model name is required for remove"
                echo "Usage: $0 models remove <model-name> [<model-name> ...]"
                return 1
            fi
            for model in "$@"; do
                if ! remove "$model"; then
                    status=1
                fi
            done
            ;;
        list)
            if [[ $# -gt 0 ]]; then
                echo "Warning: Ignoring extra arguments for 'models list'"
            fi
            list
            ;;
        *)
            echo "Error: Unknown models action '$action'"
            echo "Available actions: add, remove, list"
            return 1
            ;;
    esac

    return $status
}

function list() {
    echo "Listing installed models..."
    
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "Error: Ollama container is not running. Please start the services first."
        return 1
    fi

    docker exec ollama ollama list
}

function open_url_in_browser() {
    local url="$1"

    if command -v xdg-open &> /dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open &> /dev/null; then
        open "$url" 2>/dev/null &
    else
        echo "‚ö†Ô∏è  Could not detect default browser. Please open $url manually."
    fi
}

function dashboard_grafana() {
    echo "Opening Grafana monitoring dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "grafana"; then
        echo "‚ùå Grafana container is not running. Please start the services first."
        return 1
    fi

    # Check if Grafana is responding
    if ! curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health 2>/dev/null | grep -q "200"; then
        echo "‚ùå Grafana is not responding yet. Please wait for it to start."
        return 1
    fi

    local url="http://localhost:3000"
    echo "Grafana is available at: $url"
    echo "Default credentials: admin / admin (change on first login)"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_openwebui() {
    echo "Opening Open WebUI dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
        echo "‚ùå Open WebUI container is not running. Please start the services first."
        return 1
    fi

    local health_status
    health_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health 2>/dev/null || echo "000")

    if [ "$health_status" != "200" ]; then
        echo "‚ùå Open WebUI is not responding yet (HTTP $health_status). Please wait for it to start."
        return 1
    fi

    local url="http://localhost:8080"
    echo "Open WebUI is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard_pgadmin() {
    echo "Opening pgAdmin dashboard..."

    if ! docker ps --format "{{.Names}}" | grep -q "pgadmin"; then
        echo "‚ùå pgAdmin container is not running. Please start the services first."
        return 1
    fi

    local pgadmin_status
    pgadmin_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5050 2>/dev/null || echo "000")

    case "$pgadmin_status" in
        200|302)
            ;;
        *)
            echo "‚ùå pgAdmin is not responding yet (HTTP $pgadmin_status). Please wait for it to start."
            return 1
            ;;
    esac

    local url="http://localhost:5050"
    echo "pgAdmin is available at: $url"
    echo "Opening in default browser..."
    open_url_in_browser "$url"
}

function dashboard() {
    if [[ $# -lt 1 ]]; then
        echo "Error: Missing dashboard target."
        echo "Usage: $0 dashboard {openwebui|grafana|pgadmin}"
        return 1
    fi

    case "$1" in
        grafana)
            dashboard_grafana
            ;;
        openwebui|open-webui|open_webui)
            dashboard_openwebui
            ;;
        pgadmin)
            dashboard_pgadmin
            ;;
        *)
            echo "Error: Unknown dashboard target '$1'"
            echo "Available targets: grafana, openwebui, pgadmin"
            return 1
            ;;
    esac
}

function help_menu() {
    echo "Usage: $0 {start|stop|restart|logs|clean|status|models|dashboard|council|help|install-completion|check-env}"
    echo "Commands:"
    echo "  start                Start the AIXCL stack"
    echo "  stop                 Stop the AIXCL stack"
    echo "  restart              Restart all services"
    echo "  logs [container] [n] Show logs for all containers or a specific container (with optional number of lines)"
    echo "  clean                Remove unused Docker containers, images, and volumes"
    echo "  status               Check services status"
    echo "  service {start|stop|restart} <name>  Control individual services"
    echo "                        Available services: ${ALL_SERVICES[*]}"
    echo "  models {add|remove|list} Manage LLM models"
    echo "  dashboard <name>     Open a web dashboard (grafana, openwebui, pgadmin)"
    echo "  council {configure|list} Configure or list LLM Council models"
    echo "  check-env            Check environment dependencies"
    echo "  help                 Show this help menu"
    echo "  install-completion   Install bash completion"
    exit 1
}

function install_completion() {
    echo "Installing bash completion for aixcl..."
    
    # Get the script directory (already set globally)
    # SCRIPT_DIR and COMPLETION_SCRIPT are already defined at script startup
    
    if [[ ! -f "$COMPLETION_SCRIPT" ]]; then
        echo "Error: Completion script not found at $COMPLETION_SCRIPT"
        exit 1
    fi
    
    # Determine the appropriate completion directory
    if [[ -d "/etc/bash_completion.d" ]] && [[ -w "/etc/bash_completion.d" ]]; then
        # System-wide installation (requires write permission)
        COMPLETION_DIR="/etc/bash_completion.d"
    elif [[ -d "$HOME/.local/share/bash-completion/completions" ]]; then
        # User-specific installation (preferred)
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
    else
        # Create user directory if it doesn't exist
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
        mkdir -p "$COMPLETION_DIR"
    fi
    
    # Copy the completion script
    cp "$COMPLETION_SCRIPT" "$COMPLETION_DIR/aixcl"
    
    echo "Bash completion installed to $COMPLETION_DIR/aixcl"
    echo "To use it immediately, run: source $COMPLETION_DIR/aixcl"
    echo "It will be automatically loaded in new shell sessions."
    
    # Add to .bashrc if not already there (with safer file handling)
    if ! grep -q "source.*$COMPLETION_DIR/aixcl" "$HOME/.bashrc"; then
        # Create backup of .bashrc before modification
        cp "$HOME/.bashrc" "$HOME/.bashrc.backup.$(date +%s)"
        
        # Create a temporary file with atomic operations
        local temp_bashrc="$(mktemp)"
        
        # Copy existing .bashrc content, removing old aixcl entries
        if grep -q "Added by aixcl installer" "$HOME/.bashrc"; then
            grep -v -A 3 "Added by aixcl installer" "$HOME/.bashrc" | sed '/^$/d' > "$temp_bashrc"
        else
            cp "$HOME/.bashrc" "$temp_bashrc"
        fi
        
        # Add new entry
        cat >> "$temp_bashrc" << EOF

# Added by aixcl installer
if [ -f "$COMPLETION_DIR/aixcl" ]; then
    source "$COMPLETION_DIR/aixcl"
fi
EOF
        
        # Atomically replace .bashrc
        mv "$temp_bashrc" "$HOME/.bashrc"
        echo "Added sourcing to ~/.bashrc for persistent completion"
    else
        echo "Completion script already referenced in ~/.bashrc"
    fi
}

function get_available_models() {
    # Get list of available models from Ollama
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running. Please start the services first."
        return 1
    fi
    
    # Get models list, skip header line, extract model names
    docker exec ollama ollama list 2>/dev/null | awk 'NR>1 {print $1}' | grep -v "^$"
}

function update_env_file() {
    local council_models="$1"
    local chairman_model="$2"
    local env_file=".env"
    
    # Check if .env file exists
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found. Please run './aixcl start' first to create it."
        return 1
    fi
    
    # Create backup
    cp "$env_file" "${env_file}.backup.$(date +%s)"
    
    # Update or add COUNCIL_MODELS
    if grep -q "^COUNCIL_MODELS=" "$env_file"; then
        # Update existing entry
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS uses BSD sed
            sed -i '' "s|^COUNCIL_MODELS=.*|COUNCIL_MODELS=${council_models}|" "$env_file"
        else
            # Linux uses GNU sed
            sed -i "s|^COUNCIL_MODELS=.*|COUNCIL_MODELS=${council_models}|" "$env_file"
        fi
    else
        # Add new entry
        echo "COUNCIL_MODELS=${council_models}" >> "$env_file"
    fi
    
    # Update or add CHAIRMAN_MODEL
    if grep -q "^CHAIRMAN_MODEL=" "$env_file"; then
        # Update existing entry
        if [[ "$(uname)" == "Darwin" ]]; then
            sed -i '' "s|^CHAIRMAN_MODEL=.*|CHAIRMAN_MODEL=${chairman_model}|" "$env_file"
        else
            sed -i "s|^CHAIRMAN_MODEL=.*|CHAIRMAN_MODEL=${chairman_model}|" "$env_file"
        fi
    else
        # Add new entry
        echo "CHAIRMAN_MODEL=${chairman_model}" >> "$env_file"
    fi
    
    echo "‚úÖ Updated .env file with council configuration"
    return 0
}

function list_council() {
    echo "üìã Current LLM Council Configuration"
    echo "===================================="
    echo ""
    
    local env_file=".env"
    
    # Check if .env file exists
    if [[ ! -f "$env_file" ]]; then
        echo "‚ùå Error: .env file not found."
        echo "   Please run './aixcl start' first to create it, then configure the council with './aixcl council configure'"
        return 1
    fi
    
    # Load environment variables from .env file
    load_env_file "$env_file"
    
    # Get council models and chairman model from environment
    local council_models="${COUNCIL_MODELS:-}"
    local chairman_model="${CHAIRMAN_MODEL:-}"
    
    # Check if council is configured
    if [[ -z "$council_models" ]] && [[ -z "$chairman_model" ]]; then
        echo "‚ö†Ô∏è  Council is not configured yet."
        echo ""
        echo "To configure the council, run:"
        echo "  ./aixcl council configure"
        return 0
    fi
    
    # Get available models from Ollama (if running)
    local available_models=""
    local can_check_models=false
    if docker ps --format "{{.Names}}" | grep -q "ollama"; then
        available_models=$(get_available_models)
        if [[ -n "$available_models" ]]; then
            can_check_models=true
        fi
    fi
    
    # Helper function to check if a model exists
    model_exists() {
        local model_to_check="$1"
        if [[ "$can_check_models" == "true" ]]; then
            echo "$available_models" | grep -q "^${model_to_check}$"
        else
            return 1
        fi
    }
    
    # Display chairman with existence check
    echo "üëë Chairman Model:"
    if [[ -n "$chairman_model" ]]; then
        if model_exists "$chairman_model"; then
            echo "   ‚úÖ $chairman_model"
        else
            if [[ "$can_check_models" == "true" ]]; then
                echo "   ‚ùå $chairman_model (not found in Ollama)"
            else
                echo "   ‚ö†Ô∏è  $chairman_model (cannot verify - Ollama not running)"
            fi
        fi
    else
        echo "   ‚ö†Ô∏è  Not set"
    fi
    
    echo ""
    
    # Display council members with existence check
    if [[ -n "$council_models" ]]; then
        echo "üë• Council Members:"
        # Split comma-separated models
        IFS=',' read -ra MEMBERS <<< "$council_models"
        local member_count=0
        local existing_count=0
        for member in "${MEMBERS[@]}"; do
            # Trim whitespace
            member=$(echo "$member" | xargs)
            if [[ -n "$member" ]]; then
                ((member_count++))
                if model_exists "$member"; then
                    echo "   [$member_count] ‚úÖ $member"
                    ((existing_count++))
                else
                    if [[ "$can_check_models" == "true" ]]; then
                        echo "   [$member_count] ‚ùå $member (not found in Ollama)"
                    else
                        echo "   [$member_count] ‚ö†Ô∏è  $member (cannot verify - Ollama not running)"
                    fi
                fi
            fi
        done
        if [[ $member_count -eq 0 ]]; then
            echo "   ‚ö†Ô∏è  No members configured"
        else
            echo ""
            echo "   Total members: $member_count"
            if [[ "$can_check_models" == "true" ]]; then
                if [[ $existing_count -lt $member_count ]]; then
                    echo "   ‚ö†Ô∏è  Only $existing_count of $member_count members are available in Ollama"
                fi
            fi
        fi
    else
        echo "üë• Council Members:"
        echo "   ‚ö†Ô∏è  Not set"
    fi
    
    echo ""
    
    # Calculate total models and existing models
    local total_models=0
    local existing_models=0
    if [[ -n "$chairman_model" ]]; then
        ((total_models++))
        if model_exists "$chairman_model"; then
            ((existing_models++))
        fi
    fi
    if [[ -n "$council_models" ]]; then
        IFS=',' read -ra MEMBERS <<< "$council_models"
        for member in "${MEMBERS[@]}"; do
            member=$(echo "$member" | xargs)
            if [[ -n "$member" ]]; then
                ((total_models++))
                if model_exists "$member"; then
                    ((existing_models++))
                fi
            fi
        done
    fi
    
    echo "üìä Summary:"
    echo "   Total models in council: $total_models"
    if [[ "$can_check_models" == "true" ]]; then
        if [[ $existing_models -eq $total_models ]] && [[ $total_models -gt 0 ]]; then
            echo "   ‚úÖ All $existing_models models are available in Ollama"
        elif [[ $existing_models -lt $total_models ]]; then
            echo "   ‚ö†Ô∏è  Only $existing_models of $total_models models are available in Ollama"
        fi
    else
        echo "   ‚ö†Ô∏è  Cannot verify model availability (Ollama not running)"
    fi
    echo ""
    
    # Check if LLM-Council service is running
    if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
        echo "‚úÖ LLM-Council service is running"
        echo ""
        if [[ "$can_check_models" == "true" ]] && [[ $existing_models -lt $total_models ]]; then
            echo "‚ö†Ô∏è  Warning: Some configured models are not available in Ollama."
            echo "   The council may not function correctly until all models are installed."
            echo ""
        else
            echo "üí° This configuration is active and will be used for the next request."
        fi
    else
        echo "‚ö†Ô∏è  LLM-Council service is not running"
        echo ""
        echo "üí° To apply this configuration:"
        echo "   1. Start services: ./aixcl start"
        echo "   2. Or restart LLM-Council: ./aixcl restart"
    fi
    
    echo ""
}

function configure_council() {
    echo "üîß Configuring LLM Council"
    echo "=========================="
    echo ""
    
    # Check if Ollama is running
    if ! docker ps --format "{{.Names}}" | grep -q "ollama"; then
        echo "‚ùå Error: Ollama container is not running."
        echo "   Please start the services first with: ./aixcl start"
        return 1
    fi
    
    # Get available models
    echo "Fetching available models from Ollama..."
    local available_models
    available_models=$(get_available_models)
    
    if [[ -z "$available_models" ]]; then
        echo "‚ùå Error: No models found in Ollama."
        echo "   Please add models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Convert to array for easier handling
    local models_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && models_array+=("$line")
    done <<< "$available_models"
    
    local model_count=${#models_array[@]}
    
    if [[ $model_count -lt 2 ]]; then
        echo "‚ùå Error: At least 2 models are required for the council (1 chairman + 1 member)."
        echo "   You currently have $model_count model(s)."
        echo "   Please add more models first with: ./aixcl models add <model-name>"
        return 1
    fi
    
    # Display available models
    echo ""
    echo "Available models:"
    echo "-----------------"
    local index=1
    for model in "${models_array[@]}"; do
        echo "  [$index] $model"
        ((index++))
    done
    echo ""
    
    # Select chairman
    local chairman_index
    local chairman_model
    while true; do
        read -p "Select chairman model (1-$model_count): " chairman_index
        if [[ "$chairman_index" =~ ^[0-9]+$ ]] && [[ "$chairman_index" -ge 1 ]] && [[ "$chairman_index" -le $model_count ]]; then
            chairman_model="${models_array[$((chairman_index - 1))]}"
            echo "‚úÖ Selected chairman: $chairman_model"
            break
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count."
        fi
    done
    
    # Select council members (up to 4 more, for a total of 5)
    local council_members=()
    local max_members=4
    local current_count=0
    local min_members_required=1  # At least 1 member required (plus chairman = 2 total)
    
    echo ""
    echo "Select council members (at least 1 member required, up to $max_members more models):"
    echo "Note: Chairman is already included. Total council size will be 1 + number of members selected."
    echo ""
    
    # Disable exit on error for the interactive loop (we handle errors manually)
    set +e
    
    # Ensure we enter the loop
    while true; do
        local remaining=$((max_members - current_count))
        local total_selected=$((${#council_members[@]} + 1))  # +1 for chairman
        
        if [[ $total_selected -ge 5 ]]; then
            echo ""
            echo "‚úÖ Maximum of 5 models reached (1 chairman + ${#council_members[@]} members)."
            break
        fi
        
        echo ""
        echo "Currently selected:"
        echo "  Chairman: $chairman_model"
        if [[ ${#council_members[@]} -gt 0 ]]; then
            echo "  Members:"
            for member in "${council_members[@]}"; do
                echo "    - $member"
            done
        else
            echo "  Members: (none yet - at least 1 required)"
        fi
        echo ""
        echo "Available models:"
        local available_count=0
        local index=1
        for model in "${models_array[@]}"; do
            local is_selected=0
            local marker=""
            if [[ "$model" == "$chairman_model" ]]; then
                marker=" (chairman)"
                is_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$model" == "$member" ]]; then
                    marker=" (selected)"
                    is_selected=1
                    break
                fi
            done
            if [[ $is_selected -eq 0 ]]; then
                marker=""
                ((available_count++))
            fi
            echo "  [$index] $model$marker"
            ((index++))
        done
        
        if [[ $available_count -eq 0 ]]; then
            echo ""
            echo "  (no more models available)"
            break
        fi
        
        # Build prompt message
        local prompt_msg="Select model (1-$model_count)"
        if [[ ${#council_members[@]} -ge $min_members_required ]]; then
            prompt_msg="$prompt_msg, or 'done' to finish"
            if [[ $remaining -gt 0 ]]; then
                prompt_msg="$prompt_msg [$remaining remaining]"
            fi
        else
            local needed=$((min_members_required - ${#council_members[@]}))
            prompt_msg="$prompt_msg (at least $needed more required)"
        fi
        prompt_msg="$prompt_msg: "
        
        echo ""
        read -p "$prompt_msg" selection
        
        # Handle 'done' option - only allow if minimum members are selected
        if [[ "$selection" == "done" ]] || [[ "$selection" == "d" ]]; then
            if [[ ${#council_members[@]} -lt $min_members_required ]]; then
                local needed=$((min_members_required - ${#council_members[@]}))
                echo "‚ùå At least $needed more member(s) required. Please select more models."
                continue
            else
                echo "‚úÖ Finished selecting council members."
                break
            fi
        fi
        
        # Validate numeric selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $model_count ]]; then
            local selected_model="${models_array[$((selection - 1))]}"
            
            # Check if already selected
            local already_selected=0
            if [[ "$selected_model" == "$chairman_model" ]]; then
                already_selected=1
            fi
            for member in "${council_members[@]}"; do
                if [[ "$selected_model" == "$member" ]]; then
                    already_selected=1
                    break
                fi
            done
            
            if [[ $already_selected -eq 1 ]]; then
                echo "‚ùå Model '$selected_model' is already selected. Please choose a different model."
            else
                council_members+=("$selected_model")
                echo "‚úÖ Added '$selected_model' to council members"
                ((current_count++))
            fi
        else
            echo "‚ùå Invalid selection. Please enter a number between 1 and $model_count"
            if [[ ${#council_members[@]} -ge $min_members_required ]]; then
                echo "   or type 'done' to finish."
            fi
        fi
    done
    
    # Re-enable exit on error
    set -e
    
    # Validate we have at least 2 models (chairman + at least 1 member)
    local total_models=$((${#council_members[@]} + 1))
    if [[ $total_models -lt 2 ]]; then
        echo ""
        echo "‚ùå Error: Council must have at least 2 models (1 chairman + 1 member)."
        echo "   You selected only the chairman."
        return 1
    fi
    
    # Build council models string (comma-separated, excluding chairman)
    local council_models_str=""
    for member in "${council_members[@]}"; do
        if [[ -z "$council_models_str" ]]; then
            council_models_str="$member"
        else
            council_models_str="$council_models_str,$member"
        fi
    done
    
    # Show summary
    echo ""
    echo "=========================="
    echo "Council Configuration Summary"
    echo "=========================="
    echo "Chairman: $chairman_model"
    echo "Council Members (${#council_members[@]}):"
    for member in "${council_members[@]}"; do
        echo "  - $member"
    done
    echo "Total models: $total_models"
    echo ""
    echo "This will update:"
    echo "  - .env file: COUNCIL_MODELS and CHAIRMAN_MODEL"
    echo ""
    
    # Ask for confirmation
    read -p "Apply this configuration? (yes/no): " confirm
    if [[ "$confirm" != "yes" ]] && [[ "$confirm" != "y" ]]; then
        echo "Configuration cancelled."
        return 0
    fi
    
    # Update .env file
    if ! update_env_file "$council_models_str" "$chairman_model"; then
        return 1
    fi
    
    echo ""
    echo "‚úÖ Council configuration updated successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Restart the LLM-Council service to apply changes:"
    echo "     ./aixcl restart"
    echo "  2. The Continue plugin will automatically use the updated configuration"
    echo ""
    
    # Ask if user wants to restart services
    read -p "Restart LLM-Council service now? (yes/no): " restart_confirm
    if [[ "$restart_confirm" == "yes" ]] || [[ "$restart_confirm" == "y" ]]; then
        echo ""
        echo "Restarting LLM-Council service..."
        set_compose_cmd
        if docker ps --format "{{.Names}}" | grep -q "llm-council"; then
            "${COMPOSE_CMD[@]}" restart llm-council
            echo "‚úÖ LLM-Council service restarted"
        else
            echo "‚ö†Ô∏è  LLM-Council service is not running. Start services with: ./aixcl start"
        fi
    fi
}

function council_cmd() {
    # Default to 'list' if no action is provided
    if [[ $# -lt 1 ]]; then
        list_council
        return 0
    fi

    local action="$1"
    shift

    case "$action" in
        configure)
            configure_council
            ;;
        list)
            list_council
            ;;
        *)
            echo "Error: Unknown council action '$action'"
            echo "Usage: $0 council [configure|list]"
            echo "Examples:"
            echo "  $0 council              - List current council configuration (default)"
            echo "  $0 council list         - List current council configuration"
            echo "  $0 council configure    - Configure council models and chairman"
            return 1
            ;;
    esac
}

function main() {
    if [[ $# -lt 1 ]]; then
        help_menu
    fi

    case "$1" in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            restart
            ;;
        logs)
            shift  # Remove the 'logs' command from the arguments
            logs "$@"  # Pass all remaining arguments to the logs function
            ;;
        clean)
            clean
            ;;
        status)
            status
            ;;
        service)
            shift
            service "$@"
            ;;
        models)
            shift
            models "$@"
            ;;
        dashboard)
            shift
            dashboard "$@"
            ;;
        help)
            help_menu
            ;;
        install-completion)
            install_completion
            ;;
        check-env)
            check_env
            ;;
        council)
            shift
            council_cmd "$@"
            ;;
        *)
            help_menu
            ;;
    esac
}

main "$@"